<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Comick — Renaissance Aesthetic (Fixed)</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Merriweather:wght@300;400;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
:root{
  --bg-1:#efe4cf; --bg-2:#e8dcc6; --panel:#f7f1e6; --accent:#7a4b1a; --muted:#6e5a49; --gold:#c9a84b;
  --card-shadow:0 24px 80px rgba(10,8,6,0.25); --radius:12px; --paper:#fbf6ee;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-2));color:var(--accent);font-family:'Merriweather', serif;-webkit-font-smoothing:antialiased}
/* subtle paper texture via inline SVG background */
body::before{content:"";position:fixed;inset:0;pointer-events:none;opacity:0.12;background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200"><defs><filter id="n"><feTurbulence baseFrequency="0.8" numOctaves="1" seed="5"/><feColorMatrix type="saturate" values="0"/><feComponentTransfer><feFuncA type="table" tableValues="0 0.08"/></feComponentTransfer></filter></defs><rect width="100%" height="100%" fill="%23ffffff" filter="url(%23n)" opacity="0.12"/></svg>');mix-blend-mode:multiply}
#app{display:flex;min-height:100vh}
#sidebar{width:320px;padding:22px;background:linear-gradient(180deg,var(--panel),#f3ead8);border-right:1px solid rgba(0,0,0,0.04);display:flex;flex-direction:column;gap:12px}
h1{margin:0;font-family:'Playfair Display',serif;font-size:20px;color:var(--accent)}
.btn{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:10px;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent);border:1px solid rgba(0,0,0,0.06);cursor:pointer;color:var(--accent);font-weight:700;box-shadow:0 6px 18px rgba(10,8,6,0.06)}
.small{font-size:13px;color:var(--muted)}
#main{flex:1;padding:20px;display:flex;flex-direction:column;align-items:center}
.header{width:100%;max-width:1400px;display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.library{width:100%;max-width:1400px;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:18px}

/* book card */
.card{background:linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.85));padding:12px;border-radius:12px;box-shadow:var(--card-shadow);cursor:pointer;min-height:300px;display:flex;flex-direction:column;border:1px solid rgba(0,0,0,0.04)}
.cover{height:240px;border-radius:8px;overflow:hidden;margin-bottom:8px;border:6px double rgba(0,0,0,0.03);background:linear-gradient(180deg,#fff8ec,#f6efe0)}
.cover img{width:100%;height:100%;object-fit:cover;display:block}
.title{font-family:'Playfair Display',serif;font-size:16px;color:var(--accent);margin-bottom:6px}
.card .meta{color:var(--muted);font-size:12px}

/* reader overlay */
#readerOverlay{display:none;position:fixed;inset:18px;z-index:3000;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);padding:12px}
#readerOverlay.show{display:flex}
#readerCard{width:100%;max-width:1200px;background:linear-gradient(180deg,#fffefb,#fbf6ee);padding:28px;border-radius:14px;box-shadow:var(--card-shadow);display:flex;flex-direction:column;max-height:calc(100% - 36px);overflow:hidden;border:2px solid rgba(0,0,0,0.03)}
#readerHeader{display:flex;justify-content:space-between;align-items:start;gap:12px;margin-bottom:10px}
#readerHeader h2{margin:0;font-family:'Playfair Display',serif;color:var(--accent)}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
#readerScroller{flex:1;overflow:auto;padding-right:10px;scroll-behavior:smooth;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.02));padding:18px;border-radius:8px}
#readingInner{margin:0 auto;max-width:86vw;background:transparent}
.chapter{margin:32px 0;opacity:0;transform:translateY(14px)}
.chapter.visible{opacity:1;transform:translateY(0);transition:all .35s cubic-bezier(.2,.9,.2,1)}
.chapter-title{font-family:'Playfair Display',serif;font-size:24px;margin:0 0 12px 0;color:var(--accent)}
.chapter-body{max-width:68ch;margin:0 auto;font-size:18px;line-height:1.9;color:var(--accent);text-align:left;hyphens:auto}
.chapter-body p:first-of-type::first-letter{float:left;font-size:64px;line-height:0.6;margin-right:8px;font-family:'Playfair Display',serif;color:var(--gold)}
.chapter-placeholder{min-height:60vh;padding:25px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.6),transparent);color:var(--muted);display:flex;align-items:center;justify-content:center;border:1px dashed rgba(0,0,0,0.03)}

#rightProgress{position:fixed;right:20px;top:64px;width:8px;height:62vh;background:rgba(0,0,0,0.03);border-radius:999px;overflow:hidden;z-index:3100}
#rightProgressFill{width:100%;height:0;background:linear-gradient(180deg,var(--gold),#e6d49a);transition:height .08s linear;border-radius:999px}

/* utilities */
#debugBar{display:flex;gap:8px;align-items:center;margin-top:8px}
#cursorOrb{position:fixed;width:20px;height:20px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;box-shadow:0 0 36px 8px rgba(201,168,75,0.12);transform:translate(-50%,-50%);z-index:4000;opacity:0.95}

@media(max-width:900px){ #sidebar{display:none} #readerCard{padding:18px} #readingInner{max-width:unset} .chapter-placeholder{min-height:40vh} #rightProgress{display:none} }
</style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h1>Comick Library</h1>
    <label class="btn">Select EPUB<input id="epubInput" type="file" accept=".epub" style="display:none"></label>
    <label class="btn">Upload Cover (opt.)<input id="coverInput" type="file" accept="image/*" style="display:none"></label>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="addBtn" class="btn">Add Book</button>
      <button id="downloadAllBtn" class="btn">Download All</button>
    </div>
    <div id="debugBar">
      <button id="showLibBtn" class="btn">Show Library (Console)</button>
      <button id="resetBtn" class="btn">Reset Library</button>
    </div>
    <div style="margin-top:10px" class="small" id="statusMsg">Status: Ready</div>
  </aside>

  <main id="main">
    <div class="header">
      <h2>Your Library</h2>
      <div class="small">Click to open • Right-click to delete • Resume restored</div>
    </div>
    <div id="library" class="library"></div>
  </main>
</div>

<!-- Reader -->
<div id="readerOverlay" aria-hidden="true">
  <div id="readerCard">
    <div id="readerHeader">
      <div>
        <h2 id="bookTitle">Book</h2>
        <div style="display:flex;align-items:center;gap:12px;margin-top:6px">
          <div id="meta" class="small"></div>
          <div id="pct" class="small">0%</div>
        </div>
      </div>
      <div class="controls">
        <label class="small">Width <input id="widthRange" type="range" min="60" max="100" value="86" style="width:120px"></label>
        <button id="colsBtn" class="btn">Cols</button>
        <button id="fontDec" class="btn">A-</button>
        <button id="fontInc" class="btn">A+</button>
        <button id="downloadBtn" class="btn">Download</button>
        <button id="exitBtn" class="btn">Exit</button>
      </div>
    </div>

    <div id="readerScroller">
      <div id="readingInner"></div>
    </div>
  </div>
</div>

<div id="rightProgress"><div id="rightProgressFill"></div></div>
<div id="cursorOrb"></div>

<script>
/* COMICK — renaissance aesthetic + bug fixes
   Changes:
   - visual restyle (parchment, ornament, drop-cap)
   - fixed duplicate event listeners
   - track/revoke only created object URLs (no global revoke)
   - safer scroll-to / resume logic
   - robust EPUB lookup / fallback handling
   - lazy hydrate with IntersectionObserver
*/

/* IndexedDB helpers */
const DB_NAME='comick_surgical_v1', STORE='series';
let _db=null;
async function openDB(){ if(_db) return _db; return new Promise((res,rej)=>{ const rq=indexedDB.open(DB_NAME,1); rq.onupgradeneeded=e=>{ const d=e.target.result; if(!d.objectStoreNames.contains(STORE)) d.createObjectStore(STORE,{keyPath:'id'}); }; rq.onsuccess=e=>{ _db=e.target.result; res(_db); }; rq.onerror=e=>{ console.error('IDB open error',e); rej(e); }; });}
async function putObj(o){ await openDB(); return new Promise((res,rej)=>{ const tx=_db.transaction(STORE,'readwrite'); tx.oncomplete=()=>res(); tx.onerror=ev=>rej(ev.target.error||ev); tx.objectStore(STORE).put(o); });}
async function getAll(){ await openDB(); return new Promise(res=>{ const tx=_db.transaction(STORE,'readonly'); const q=tx.objectStore(STORE).getAll(); q.onsuccess=e=>res(e.target.result||[]); });}
async function getById(id){ await openDB(); return new Promise(res=>{ const tx=_db.transaction(STORE,'readonly'); tx.objectStore(STORE).get(id).onsuccess=e=>res(e.target.result); });}
async function deleteById(id){ await openDB(); return new Promise((res,rej)=>{ const tx=_db.transaction(STORE,'readwrite'); const r=tx.objectStore(STORE).delete(id); r.onsuccess=()=>res(); r.onerror=rej; });}

/* DOM */
const epubInput = document.getElementById('epubInput'), coverInput = document.getElementById('coverInput');
const addBtn = document.getElementById('addBtn'), downloadAllBtn = document.getElementById('downloadAllBtn');
const showLibBtn = document.getElementById('showLibBtn'), resetBtn = document.getElementById('resetBtn');
const statusMsg = document.getElementById('statusMsg'), libraryEl = document.getElementById('library');

const readerOverlay = document.getElementById('readerOverlay'), readingInner = document.getElementById('readingInner');
const readerScroller = document.getElementById('readerScroller'), bookTitle = document.getElementById('bookTitle');
const pctEl = document.getElementById('pct'), metaEl = document.getElementById('meta');
const widthRange = document.getElementById('widthRange'), colsBtn = document.getElementById('colsBtn'), fontInc = document.getElementById('fontInc'), fontDec = document.getElementById('fontDec');
const downloadBtn = document.getElementById('downloadBtn'), exitBtn = document.getElementById('exitBtn');
const rightProgressFill = document.getElementById('rightProgressFill'), cursorOrb = document.getElementById('cursorOrb');

let library=[], pending=null, zip=null, chapters=[], current=null, currentIndex=0, observer=null;
const createdObjectURLs = new Set(); // track only our created blob: URLs so we revoke safely

/* helpers */
function uid(){ return 's_'+Date.now()+'_'+Math.random().toString(36).slice(2,8); }
function showStatus(txt){ statusMsg.textContent = 'Status: '+txt; }
function readArrayBuffer(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(file); });}
function readDataUrl(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); });}
function downloadBlob(b,name){ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },1200); }
function escapeHtml(s){ return (s||'').replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }

/* EPUB helpers (robust-ish) */
function tryGetFile(z,path){ if(!path) return null; if(z.file(path)) return z.file(path); try{ const d=decodeURIComponent(path); if(z.file(d)) return z.file(d);}catch(e){} const p=path.replace(/^\.\//,'').replace(/^\/+/, ''); if(z.file(p)) return z.file(p); const name=p.split('/').pop(); const keys=Object.keys(z.files); const found=keys.find(k=>k.endsWith('/'+name)||k.endsWith(name)); return found? z.file(found):null; }
function xmlParse(str){ try{ return (new DOMParser()).parseFromString(str,'application/xml'); }catch(e){ return null; } }
async function findOpf(z){ const c=tryGetFile(z,'META-INF/container.xml')||tryGetFile(z,'container.xml'); if(!c) return null; const txt=await c.async('string'); const doc=xmlParse(txt); if(!doc) return null; const rf=doc.getElementsByTagName('rootfile')[0]; if(rf && rf.getAttribute) return rf.getAttribute('full-path'); const all=doc.getElementsByTagName('*'); for(const n of all) if(n.localName==='rootfile' && n.getAttribute){ const p=n.getAttribute('full-path'); if(p) return p; } return null; }
async function readSpine(z){ const opfPath = await findOpf(z); if(!opfPath) throw new Error('OPF not found'); const opfFile = tryGetFile(z, opfPath); if(!opfFile) throw new Error('OPF missing'); const opfStr = await opfFile.async('string'); const opfDoc = xmlParse(opfStr); const base = opfPath.split('/').slice(0,-1).join('/'); const manifest={}; const manEls = opfDoc.getElementsByTagName('manifest'); const items = manEls.length ? manEls[0].getElementsByTagName('item') : opfDoc.getElementsByTagName('item'); for(const it of items){ const id = it.getAttribute('id')||it.getAttribute('xml:id')||''; manifest[id] = { href: it.getAttribute('href'), type: it.getAttribute('media-type'), props: it.getAttribute('properties')||'' }; } const spineEls = opfDoc.getElementsByTagName('spine'); const refs = spineEls.length ? spineEls[0].getElementsByTagName('itemref') : opfDoc.getElementsByTagName('itemref'); const spineList=[]; for(const r of refs){ const idref = r.getAttribute('idref')||r.getAttribute('id')||r.getAttribute('href')||''; if(idref) spineList.push(idref); } if(spineList.length===0){ for(const k in manifest){ const m=manifest[k]; if(m.type && (m.type.includes('html')||m.type.includes('xhtml')||m.type.includes('xml'))) spineList.push(k); } } return { base, manifest, spineList, opfDoc }; }
function buildChapters(base, manifest, spineList){ const out=[]; for(const idref of spineList){ let it = manifest[idref]; if(!it){ for(const k in manifest) if(k===idref || manifest[k].href===idref) it = manifest[k]; } if(!it) continue; out.push({ href:(base? base + '/':'') + it.href, idref, title: it.href }); } if(out.length===0){ for(const k in manifest){ const it=manifest[k]; if(it.type && it.type.includes('html')) out.push({ href:(base? base + '/':'')+it.href, idref:k, title:it.href }); } } return out; }
async function loadChapter(z, base, href){
  const file = tryGetFile(z,href) || tryGetFile(z,decodeURIComponent(href)); if(!file) throw new Error('Chapter missing: '+href);
  const raw = await file.async('string'); let doc;
  try{ doc=(new DOMParser()).parseFromString(raw,'application/xml'); }catch(e){ doc=(new DOMParser()).parseFromString(raw,'text/html'); }
  // inline CSS
  try{
    const linkEls = Array.from(doc.getElementsByTagName('link'));
    for(const link of linkEls){ const rel=(link.getAttribute('rel')||'').toLowerCase(); if(rel==='stylesheet'){ const cssHref=link.getAttribute('href')||''; const cand=[(base? base + '/':'')+cssHref, cssHref, decodeURIComponent(cssHref)]; let cssFile=null; for(const c of cand){ cssFile = tryGetFile(z,c); if(cssFile) break; } if(cssFile){ try{ const css = await cssFile.async('string'); const st = doc.createElement('style'); st.textContent = css; link.parentNode.replaceChild(st, link); }catch(e){ link.remove(); } } else link.remove(); } }
  }catch(e){ /* ignore CSS inlining errors */ }
  // inline images
  try{
    const imgs = Array.from(doc.getElementsByTagName('img'));
    for(const img of imgs){ const src=img.getAttribute('src')||''; if(!src) continue; const cand=[(base? base + '/':'')+src, src, decodeURIComponent(src)]; let f=null; for(const c of cand){ f = tryGetFile(z,c); if(f) break; } if(f){ try{ const blob=await f.async('blob'); const url=URL.createObjectURL(blob); createdObjectURLs.add(url); img.setAttribute('src',url); img.setAttribute('loading','lazy'); }catch(e){} } }
  }catch(e){ /* ignore image inlining errors */ }
  const ser = new XMLSerializer(); const bodies = doc.getElementsByTagName('body'); let html=''; if(bodies && bodies.length>0) html = ser.serializeToString(bodies[0]).replace(/^<body[^>]*>/i,'').replace(/<\/body>$/i,''); else html = ser.serializeToString(doc);
  const t = doc.getElementsByTagName('title')[0] || (doc.querySelector && doc.querySelector('h1'));
  const title = t? (t.textContent||'').trim() : href.split('/').pop();
  return { html, title };
}

/* UI render + dedupe */
async function renderLibrary(){
  libraryEl.innerHTML=''; showStatus('Loading library...');
  let items = await getAll().catch(()=>[]);
  // dedupe by title (case-insensitive): keep first valid epubBlob and highest lastIndex
  const map = new Map();
  for(const it of items){
    const key = (it.title||'').trim().toLowerCase() || it.id;
    if(!map.has(key)) map.set(key, Object.assign({}, it));
    else {
      const existing = map.get(key);
      if(!existing.epubBlob && it.epubBlob) existing.epubBlob = it.epubBlob;
      existing.lastIndex = Math.max(Number(existing.lastIndex||0), Number(it.lastIndex||0));
    }
  }
  items = Array.from(map.values());
  // if dedupe changed underlying DB count, re-save deduped (safe local operation)
  const orig = await getAll().catch(()=>[]);
  if(items.length !== orig.length){
    try{
      const db = await openDB(); await new Promise(res=>{ const tx=db.transaction(STORE,'readwrite'); const store=tx.objectStore(STORE); const r=store.clear(); r.onsuccess=res; r.onerror=res; });
      for(const it of items) await putObj(it);
    }catch(e){ console.warn('Failed to rewrite deduped DB',e); }
  }
  library = items.sort((a,b)=>(a.title||'').localeCompare(b.title||''));
  if(library.length===0){ libraryEl.innerHTML='<div style="color:var(--muted);padding:24px">Library empty — import an EPUB</div>'; showStatus('Ready'); return; }
  for(const b of library){
    const card = document.createElement('div'); card.className='card';
    const cover = b.cover || placeholder(b.title);
    const size = b.epubBlob ? Math.round((b.epubBlob.size||0)/1024)+'KB' : (b.epubBase64 ? 'base64' : '—');
    const meta = document.createElement('div'); meta.className='meta'; meta.textContent = `${b.lastIndex? 'Resume':'New'} • ${size}`;
    const coverWrap = document.createElement('div'); coverWrap.className='cover'; const img = document.createElement('img'); img.src = cover; coverWrap.appendChild(img);
    const titleEl = document.createElement('div'); titleEl.className='title'; titleEl.innerHTML = escapeHtml(b.title);
    card.appendChild(coverWrap); card.appendChild(titleEl); card.appendChild(meta);
    card.addEventListener('click', ()=> openWithReveal(b.id));
    card.addEventListener('contextmenu', e=>{ e.preventDefault(); if(confirm('Delete "'+b.title+'"?')) deleteById(b.id).then(()=>renderLibrary()); });
    libraryEl.appendChild(card);
  }
  showStatus('Ready');
}
function placeholder(title){ const txt = escapeHtml(title||'Untitled'); return 'data:image/svg+xml;utf8,'+encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='900' height='1200'><rect width='100%' height='100%' fill='%23efe4cf'/><g fill='%236e5a49' font-family='Playfair Display' font-size='28' text-anchor='middle'><text x='50%' y='50%' dy='0'>${txt}</text></g></svg>`); }

/* Import flow */
epubInput.addEventListener('change', async ()=>{
  const f = epubInput.files[0]; if(!f) return;
  try{
    showStatus('Reading EPUB...');
    const ab = await readArrayBuffer(f); const z = await JSZip.loadAsync(ab);
    pending = { file: f, arrayBuffer: ab, zip: z, chosenCover: null };
    try{
      const spine = await readSpine(z);
      const manifest = spine.manifest;
      for(const k in manifest){
        const it = manifest[k];
        if(it.props && (''+it.props).includes('cover-image')){ const file = tryGetFile(z, (spine.base? spine.base + '/':'')+it.href)||tryGetFile(z,it.href); if(file){ const blob = await file.async('blob'); pending.chosenCover = await blobToDataURL(blob); break; } }
        if(it.href && it.href.toLowerCase().includes('cover') && it.type && it.type.startsWith('image')){ const file = tryGetFile(z, (spine.base? spine.base + '/':'')+it.href)||tryGetFile(z,it.href); if(file){ const blob = await file.async('blob'); pending.chosenCover = await blobToDataURL(blob); break; } }
      }
    }catch(e){ /* ignore spine heuristics */ }
    if(coverInput.files && coverInput.files[0]) pending.chosenCover = await readDataUrl(coverInput.files[0]);
    showStatus('Ready to Add Book. Click "Add Book" to save.');
  }catch(e){ console.error('Import error',e); alert('Failed to read EPUB: '+(e.message||e)); pending=null; showStatus('Ready'); }
});

/* Convert blob to dataURL */
function blobToDataURL(blob){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }

/* Add Book handler: stores epubBlob + cover + lastIndex:0 */
addBtn.addEventListener('click', async ()=>{
  if(!pending || !pending.file){ alert('No EPUB selected.'); return; }
  try{
    showStatus('Saving book...');
    const id = uid();
    const title = pending.file.name.replace(/\.epub$/i,'') || id;
    const blob = new Blob([pending.arrayBuffer], { type: 'application/epub+zip' });
    const record = { id, title, epubBlob: blob, cover: pending.chosenCover || null, lastIndex: 0 };
    await putObj(record);
    pending = null; epubInput.value=''; coverInput.value='';
    await renderLibrary();
    showStatus('Book saved');
  }catch(e){ console.error('Save failed',e); alert('Save failed: '+(e.message||e)); showStatus('Ready'); }
});

/* Simple debug and reset (single handlers, no duplicates) */
showLibBtn.addEventListener('click', async ()=>{
  const all = await getAll();
  console.log('=== Comick Library ===', all);
  alert('Library dumped to Console. Open DevTools (Ctrl+Shift+I) → Console.');
});
resetBtn.addEventListener('click', async ()=>{
  if(!confirm('Reset local library (permanent delete)?')) return;
  try{
    const db = await openDB();
    await new Promise(res=>{ const tx = db.transaction(STORE,'readwrite'); const r = tx.objectStore(STORE).clear(); r.onsuccess = ()=> res(); r.onerror = ()=> res(); });
    await renderLibrary();
    alert('Library reset complete.');
  }catch(e){ console.error('Reset failed',e); alert('Reset failed: see console.'); }
});

/* Reader open: loads first chapter fully then shows overlay */
async function openWithReveal(id){
  const s = await getById(id);
  if(!s) return alert('Book missing');
  const reveal = document.createElement('div'); reveal.style.position='fixed'; reveal.style.inset='0'; reveal.style.display='flex'; reveal.style.alignItems='center'; reveal.style.justifyContent='center'; reveal.style.zIndex='3600'; reveal.style.background='rgba(0,0,0,0.6)';
  const c = document.createElement('div'); c.style.width='70vw'; c.style.maxWidth='780px'; c.style.borderRadius='12px'; c.style.overflow='hidden'; c.style.boxShadow='0 40px 120px rgba(0,0,0,0.85)';
  const img = document.createElement('img'); img.src = s.cover || placeholder(s.title); img.style.width='100%'; c.appendChild(img); reveal.appendChild(c); document.body.appendChild(reveal);
  setTimeout(()=>{ try{ document.body.removeChild(reveal); }catch(e){} openReader(id); }, 420);
}

async function openReader(id){
  try{
    showStatus('Preparing reader...');
    current = await getById(id); if(!current) throw new Error('Missing stored record');
    bookTitle.textContent = current.title || 'Book';
    let ab = null;
    if(current.epubBlob instanceof Blob) ab = await current.epubBlob.arrayBuffer();
    else if(current.epubBase64){ const r = await fetch(current.epubBase64); const b = await r.blob(); ab = await b.arrayBuffer(); }
    else throw new Error('No EPUB binary stored');
    zip = await JSZip.loadAsync(ab);
    const spine = await readSpine(zip);
    chapters = buildChapters(spine.base, spine.manifest, spine.spineList);
    if(!chapters || chapters.length===0){ alert('No readable chapters'); return; }
    showStatus('Loading chapter 1...');
    const base0 = chapters[0].href.split('/').slice(0,-1).join('/');
    const first = await loadChapter(zip, base0, chapters[0].href).catch(e=>{ console.error('first load fail',e); return null; });
    if(!first) { alert('Failed to load first chapter'); return; }
    // build DOM
    readingInner.innerHTML='';
    const n0 = document.createElement('div'); n0.className='chapter visible'; n0.dataset.idx='0';
    n0.innerHTML = `<div class="chapter-title">${escapeHtml(first.title||chapters[0].title||'Chapter 1')}</div><div class="chapter-body">${first.html}</div>`;
    readingInner.appendChild(n0);
    for(let i=1;i<chapters.length;i++){ const ph=document.createElement('div'); ph.className='chapter-placeholder'; ph.dataset.idx=String(i); ph.textContent=chapters[i].title||('Chapter '+(i+1)); ph.style.minHeight=(window.innerHeight*0.62)+'px'; readingInner.appendChild(ph); }
    readerOverlay.classList.add('show'); readerOverlay.setAttribute('aria-hidden','false');
    readingInner.style.maxWidth = widthRange.value + 'vw';
    if(observer){ observer.disconnect(); observer=null; }
    observer = new IntersectionObserver(async entries=>{ for(const e of entries){ if(e.isIntersecting){ const idx = Number(e.target.dataset.idx); if(Number.isFinite(idx) && idx>0) hydrateChapter(idx); } }}, { root: readerScroller, rootMargin:'600px', threshold:0.02 });
    Array.from(readingInner.querySelectorAll('.chapter-placeholder')).forEach(el=>observer.observe(el));
    const stored = (typeof current.lastIndex==='number' && Number.isFinite(current.lastIndex)) ? current.lastIndex : 0;
    currentIndex = Math.max(0, Math.min(stored, chapters.length-1));
    setTimeout(()=> scrollToChapter(currentIndex,false), 120);
    readerScroller.removeEventListener('scroll', handleScroll); readerScroller.addEventListener('scroll', throttle(handleScroll,80));
    updateNavButtons();
    showStatus('Ready');
    document.getElementById('sidebar').style.transform = 'translateX(-120%)'; // hide sidebar visually
  }catch(e){ console.error('openReader error', e); alert('Failed to open book: '+(e.message||e)); showStatus('Ready'); }
}

async function hydrateChapter(idx){
  if(!zip || !chapters[idx]) return;
  const ph = readingInner.querySelector('.chapter-placeholder[data-idx="'+String(idx)+'"]'); if(!ph) return;
  if(ph.classList.contains('loaded')) return;
  ph.classList.add('loaded');
  try{
    const base = chapters[idx].href.split('/').slice(0,-1).join('/');
    const res = await loadChapter(zip, base, chapters[idx].href);
    ph.className='chapter'; ph.dataset.idx=String(idx); ph.innerHTML=`<div class="chapter-title">${escapeHtml(res.title||chapters[idx].title||('Chapter '+(idx+1)))}</div><div class="chapter-body">${res.html}</div>`;
    setTimeout(()=> ph.classList.add('visible'),60);
  }catch(e){ console.error('hydrate error',e); ph.textContent='Failed to load chapter'; }
}

/* scroll progress & resume save (clamped) */
function handleScroll(){
  const st = readerScroller.scrollTop; const sh = readerScroller.scrollHeight - readerScroller.clientHeight;
  const pct = sh>0 ? Math.round((st/sh)*100):0;
  pctEl.textContent = pct+'%';
  rightProgressFill.style.height = pct+'%';
  const nodes = Array.from(readingInner.querySelectorAll('.chapter, .chapter-placeholder'));
  const rr = readerScroller.getBoundingClientRect();
  let best={idx:0,vis:0};
  for(const n of nodes){
    const r = n.getBoundingClientRect();
    const vis = Math.max(0, Math.min(r.bottom, rr.bottom) - Math.max(r.top, rr.top));
    const idx = Number(n.dataset.idx);
    if(vis>best.vis && Number.isFinite(idx)) best={ idx, vis };
  }
  if(Number.isFinite(best.idx) && best.idx>=0 && best.idx < chapters.length && best.idx !== currentIndex){
    currentIndex = best.idx;
    if(current){ const c = Math.max(0, Math.min(currentIndex, chapters.length-1)); current.lastIndex = c; putObj(current).catch(e=>console.error('save lastIndex failed',e)); }
    updateNavButtons();
  }
}
function scrollToChapter(idx, smooth=true){
  const el = readingInner.querySelector('.chapter[data-idx="'+String(idx)+'"], .chapter-placeholder[data-idx="'+String(idx)+'"]');
  if(!el) return;
  // compute offset relative to readerScroller
  const top = el.offsetTop - (readingInner.offsetTop || 0) - 6;
  readerScroller.scrollTo({ top: Math.max(0, top), behavior: smooth?'smooth':'auto' });
  currentIndex = idx;
  if(current){ current.lastIndex = currentIndex; putObj(current).catch(e=>console.error('save lastIndex failed',e)); }
  updateNavButtons();
}
function updateNavButtons(){ prevBtn.disabled = !(currentIndex>0); nextBtn.disabled = !(currentIndex<chapters.length-1); }

/* nav btns */
const prevBtn = document.createElement('button'), nextBtn = document.createElement('button');
prevBtn.textContent='⟵ Prev'; nextBtn.textContent='Next ⟶';
prevBtn.className='btn'; nextBtn.className='btn';
prevBtn.style.pointerEvents='auto'; nextBtn.style.pointerEvents='auto';
prevBtn.addEventListener('click', ()=>{ if(currentIndex>0) scrollToChapter(currentIndex-1); });
nextBtn.addEventListener('click', ()=>{ if(currentIndex < chapters.length-1) scrollToChapter(currentIndex+1); });
const footer = document.createElement('div'); footer.style.display='flex'; footer.style.justifyContent='center'; footer.style.gap='12px'; footer.style.marginTop='12px';
footer.appendChild(prevBtn); footer.appendChild(nextBtn);
document.getElementById('readerCard').appendChild(footer);

/* exit */
exitBtn.addEventListener('click', closeReader);
readerOverlay.addEventListener('click', e=>{ if(e.target===readerOverlay) closeReader(); });
document.addEventListener('keydown', e=>{ if(e.key==='Escape' && readerOverlay.classList.contains('show')) closeReader(); });

function closeReader(){
  if(current){ current.lastIndex = Math.max(0, Math.min(currentIndex, chapters.length-1)); putObj(current).catch(e=>console.error('final save err',e)); }
  readerOverlay.classList.remove('show'); readerOverlay.setAttribute('aria-hidden','true');
  readerScroller.removeEventListener('scroll', handleScroll);
  if(observer){ observer.disconnect(); observer=null; }
  // revoke only created blob urls
  try{ for(const u of createdObjectURLs){ try{ URL.revokeObjectURL(u); }catch(e){} } createdObjectURLs.clear(); }catch(e){}
  readingInner.innerHTML = ''; zip=null; chapters=[]; current=null; currentIndex=0;
  document.getElementById('sidebar').style.transform=''; showStatus('Ready');
  rightProgressFill.style.height='0%'; pctEl.textContent='0%';
}

/* controls */
widthRange.addEventListener('input', ()=>{ readingInner.style.maxWidth = widthRange.value + 'vw'; });
colsBtn.addEventListener('click', ()=>{ const cur = window.getComputedStyle(readingInner).columnCount || '1'; readingInner.style.columnCount = (cur==='1' || cur==='auto' ? '2' : '1'); readingInner.style.columnGap='40px'; });
fontInc.addEventListener('click', ()=>{ const els = document.querySelectorAll('.chapter-body'); els.forEach(n=>{ const s = parseInt(window.getComputedStyle(n).fontSize) || 18; n.style.fontSize = Math.min(26, s+1)+'px'; });});
fontDec.addEventListener('click', ()=>{ const els = document.querySelectorAll('.chapter-body'); els.forEach(n=>{ const s = parseInt(window.getComputedStyle(n).fontSize) || 18; n.style.fontSize = Math.max(14, s-1)+'px'; });});
downloadBtn.addEventListener('click', async ()=>{ if(!current) return alert('Open a book first'); const s = await getById(current.id); if(!s) return alert('No EPUB stored'); try{ let blob=null; if(s.epubBlob instanceof Blob) blob=s.epubBlob; else if(s.epubBase64){ const r = await fetch(s.epubBase64); blob = await r.blob(); } if(!blob) return alert('No EPUB data'); downloadBlob(blob, (s.title||'book')+'.epub'); }catch(e){ console.error('dl err',e); alert('Download failed: '+(e.message||e)); }});

/* download all */
downloadAllBtn.addEventListener('click', async ()=>{ const all = await getAll(); if(!all||all.length===0){ alert('No books'); return; } const z = new JSZip(); for(const s of all){ if(s.epubBlob instanceof Blob) z.file((s.title||s.id)+'.epub', s.epubBlob); else if(s.epubBase64){ const r = await fetch(s.epubBase64); const b = await r.blob(); z.file((s.title||s.id)+'.epub', b); } } const blob = await z.generateAsync({type:'blob'}); downloadBlob(blob,'comick_library.zip'); });

/* mouse orb for polish */
document.addEventListener('mousemove', e=>{ cursorOrb.style.left = e.clientX + 'px'; cursorOrb.style.top = e.clientY + 'px'; });

/* throttle utility */
function throttle(fn, wait=120){ let t=null; return (...a)=>{ if(t) return; t=setTimeout(()=>{ t=null; fn(...a); }, wait); }; }

/* init */
(async function init(){ try{ await openDB(); await renderLibrary(); showStatus('Ready'); }catch(e){ console.error('init init',e); showStatus('Init failed'); } })();
</script>
</body>
</html>
