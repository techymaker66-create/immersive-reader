<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Comick-style Immersive Reader</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/epubjs@0.3.93/dist/epub.min.js"></script>
<style>
:root{
  --bg:#0d0d0f; --panel:#121216; --muted:#9b9b9b; --accent:#f5f5dc;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:'Playfair Display',serif;background:var(--bg);color:var(--accent);}
#app{display:flex;min-height:100vh}
#sidebar{
  width:320px;padding:28px;background:linear-gradient(180deg,#0b0b0d,#0f0f12);
  border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;
}
#main{flex:1;padding:28px;display:flex;flex-direction:column;align-items:center}
h1{margin:0 0 12px 0;font-size:20px;letter-spacing:1px}
.controls{margin:12px 0 22px 0;display:flex;flex-direction:column;gap:10px}
.add-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--accent);cursor:pointer;transition:all .18s ease;text-align:left}
.add-btn:hover{border-color:var(--accent)}
.tiles{display:flex;flex-wrap:wrap;gap:18px}
.tile{width:160px;height:240px;border-radius:10px;overflow:hidden;position:relative;background:#18181a;box-shadow:0 6px 18px rgba(0,0,0,0.6);cursor:pointer;transition:transform .25s,box-shadow .25s}
.tile img{width:100%;height:100%;object-fit:cover;display:block}
.tile:hover{transform:translateY(-6px) scale(1.02);box-shadow:0 12px 30px rgba(0,0,0,0.7)}
.tile .meta{position:absolute;left:0;right:0;bottom:0;padding:10px;background:linear-gradient(180deg,transparent, rgba(0,0,0,0.6));display:flex;justify-content:space-between;align-items:center}
.tile .meta .title{font-size:13px}
.tile .meta .resume{font-size:12px;color:var(--muted)}
.tile .delete-btn{position:absolute;top:6px;right:6px;background:rgba(255,0,0,0.75);border:none;color:#fff;border-radius:50%;width:20px;height:20px;font-size:14px;cursor:pointer;display:flex;align-items:center;justify-content:center;z-index:10}
#readerWrap{display:none;flex-direction:column;align-items:center;position:relative;width:100%;height:100vh}
#readerHeader{width:100%;display:flex;justify-content:space-between;align-items:center;padding:22px 40px;position:fixed;top:0;left:0;z-index:50;background:linear-gradient(180deg, rgba(10,10,10,0.9), transparent);backdrop-filter: blur(2px)}
#readerHeader h2{margin:0;font-size:18px}
#viewerContainer{width:820px;max-width:92%;margin-top:98px;margin-bottom:80px;position:relative}
#viewer{background:rgba(0,0,0,0.35);padding:36px 48px;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.7);max-height:74vh;overflow:auto}
/* CRITICAL FIX BELOW! */
#viewer p { opacity:1 !important; color:var(--accent); background:transparent; }
#viewer .dropcap{float:left;font-size:64px;line-height:56px;padding-right:12px;padding-top:8px;color:var(--accent)}
#progressBar{position:fixed;right:20px;top:20px;width:10px;height:60vh;background:rgba(255,255,255,0.03);border-radius:20px;overflow:hidden}
#progressFill{width:100%;height:0;background:linear-gradient(180deg,var(--accent), #d4d4b8)}
.nav{position:fixed;left:0;right:0;bottom:24px;display:flex;justify-content:space-between;padding:0 40px;pointer-events:none}
.nav button{pointer-events:auto;background:linear-gradient(145deg,#2a2a2a,#171717);border-radius:28px;padding:14px 22px;border:none;color:var(--accent);font-size:16px;box-shadow:0 8px 22px rgba(0,0,0,0.6);cursor:pointer;transition:transform .18s,box-shadow .18s}
.nav button:hover{transform:scale(1.06);box-shadow:0 14px 34px rgba(0,0,0,0.75)}
.nav button:active{transform:scale(.96)}
#fog{position:fixed;inset:0;background:radial-gradient(circle at 50% 40%, rgba(255,255,255,0.02), rgba(255,255,255,0.01) 10%, rgba(0,0,0,0.85) 40%);pointer-events:none;opacity:0;transition:opacity .6s;z-index:90}
#cursorGlow{position:fixed;width:22px;height:22px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;box-shadow:0 0 32px 10px rgba(245,245,220,0.22);transform:translate(-50%,-50%);z-index:200;transition:all .18s ease}
@media (max-width:900px){#sidebar{display:none}#viewer{padding:22px}}
</style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h1>Comick Library</h1>
    <div class="controls">
      <label class="add-btn">Select EPUB
        <input id="epubInput" type="file" accept=".epub" style="display:none">
      </label>
      <label class="add-btn">Select Cover
        <input id="coverInput" type="file" accept="image/*" style="display:none">
      </label>
      <button id="addSeriesBtn" class="add-btn">Add Series</button>
    </div>
    <div id="statusMsg" style="color:var(--muted);font-size:13px;margin-top:10px">Ready</div>
  </aside>
  <main id="main">
    <div id="homepageView" style="width:100%;max-width:1200px">
      <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-bottom:18px">
        <h2 style="margin:0">Your Library</h2>
        <div style="color:var(--muted);font-size:13px">Tap a cover to open • Long-press or right-click to delete</div>
      </div>
      <div class="tiles" id="tiles"></div>
    </div>
    <div id="readerWrap">
      <div id="readerHeader">
        <h2 id="seriesTitle">Series</h2>
        <div>
          <button id="gotoHome" class="add-btn">Library</button>
          <button id="downloadEpub" class="add-btn">Download EPUB</button>
        </div>
      </div>
      <div id="viewerContainer">
        <div id="viewer" tabindex="0"></div>
      </div>
      <div id="progressBar"><div id="progressFill"></div></div>
      <div class="nav">
        <button id="prevBtn">⟵ Prev</button>
        <button id="nextBtn">Next ⟶</button>
      </div>
    </div>
  </main>
</div>
<div id="fog"></div>
<div id="cursorGlow"></div>
<script>
const DB_NAME = 'comickDB';
const STORE_NAME = 'seriesStore';
let db = null;
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = (e)=>{
      db = e.target.result;
      if(!db.objectStoreNames.contains(STORE_NAME)){
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
    req.onsuccess = (e)=>{
      db = e.target.result;
      resolve(db);
    };
    req.onerror = (e)=> reject(e);
  });
}
function getAllSeries(){
  return new Promise(async (res, rej)=>{
    if(!db) await openDB();
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const req = store.getAll();
    req.onsuccess = ()=> res(req.result);
    req.onerror = ()=> rej(req.error);
  });
}
function saveSeries(obj){
  return new Promise(async (res, rej)=>{
    if(!db) await openDB();
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    const req = store.put(obj);
    req.onsuccess = ()=> res();
    req.onerror = ()=> rej(req.error);
  });
}
function getSeriesById(id){
  return new Promise(async (res, rej)=>{
    if(!db) await openDB();
    const tx = db.transaction(STORE_NAME,'readonly');
    const store = tx.objectStore(STORE_NAME);
    const req = store.get(id);
    req.onsuccess = ()=> res(req.result);
    req.onerror = ()=> rej(req.error);
  });
}
function deleteSeriesById(id){
  return new Promise(async (res, rej)=>{
    if(!db) await openDB();
    const tx = db.transaction(STORE_NAME,'readwrite');
    const req = tx.objectStore(STORE_NAME).delete(id);
    req.onsuccess = ()=> res();
    req.onerror = ()=> rej(req.error);
  });
}
const tilesEl = document.getElementById('tiles');
const epubInput = document.getElementById('epubInput');
const coverInput = document.getElementById('coverInput');
const addBtn = document.getElementById('addSeriesBtn');
const statusMsg = document.getElementById('statusMsg');
const readerWrap = document.getElementById('readerWrap');
const homepageView = document.getElementById('homepageView');
const seriesTitle = document.getElementById('seriesTitle');
const viewer = document.getElementById('viewer');
const downloadEpubBtn = document.getElementById('downloadEpub');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const gotoHomeBtn = document.getElementById('gotoHome');
const progressFill = document.getElementById('progressFill');
const fog = document.getElementById('fog');
function showStatus(txt){
  statusMsg.textContent = txt;
}
function dataURLFromFile(file){
  return new Promise((res, rej)=>{
    const r = new FileReader();
    r.onload = ()=> res(r.result);
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}
function downloadBlob(blob, filename){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
}
async function renderLibrary(){
  tilesEl.innerHTML = '';
  showStatus('Loading library...');
  let list = [];
  try{
    list = await getAllSeries();
  }catch(e){
    console.error(e);
  }
  list.sort((a,b)=> (a.title||'').localeCompare(b.title||''));
  list.forEach(series=>{
    const tile = document.createElement('div');
    tile.className = 'tile';
    const img = document.createElement('img');
    img.src = series.cover || placeholderCover();
    const meta = document.createElement('div');
    meta.className = 'meta';
    const t = document.createElement('span'); t.className='title'; t.textContent = series.title || 'Untitled';
    const r = document.createElement('span'); r.className='resume'; r.textContent = series.lastCfi ? 'Resume' : '';
    meta.appendChild(t); meta.appendChild(r);
    const delBtn = document.createElement('button');
    delBtn.className = 'delete-btn';
    delBtn.innerText = '×';
    delBtn.addEventListener('click', async (ev)=>{
      ev.stopPropagation();
      if(confirm(`Delete series "${series.title}"? This will remove stored EPUB and progress.`)){
        await deleteSeriesById(series.id);
        renderLibrary();
      }
    });
    let holdTimer = null;
    tile.addEventListener('mousedown', (ev)=>{
      holdTimer = setTimeout(async ()=>{
        if(confirm(`Delete series "${series.title}"?`)){
          await deleteSeriesById(series.id);
          renderLibrary();
        }
      }, 800);
    });
    tile.addEventListener('mouseup', ()=>{ if(holdTimer) clearTimeout(holdTimer); });
    tile.addEventListener('mouseleave', ()=>{ if(holdTimer) clearTimeout(holdTimer); });
    tile.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault();
      if(confirm(`Delete series "${series.title}"?`)){
        deleteSeriesById(series.id).then(renderLibrary);
      }
    });
    tile.addEventListener('click', ()=> openSeries(series.id));
    tile.appendChild(img);
    tile.appendChild(meta);
    tile.appendChild(delBtn);
    tilesEl.appendChild(tile);
  });
  showStatus('Ready');
}
function placeholderCover(){
  return 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='800' height='1200'><rect width='100%' height='100%' fill='#111'/><text x='50%' y='50%' font-size='40' fill='#e6e0c8' text-anchor='middle' font-family='Playfair Display'>Untitled</text></svg>`);
}
addBtn.addEventListener('click', async ()=>{
  const epubFile = epubInput.files[0];
  const coverFile = coverInput.files[0];
  if(!epubFile || !coverFile){
    alert('You must select both an EPUB and a cover image before adding.');
    return;
  }
  try{
    showStatus('Caching EPUB...');
    const epubBlob = epubFile.slice(0, epubFile.size, epubFile.type || 'application/epub+zip');
    const coverData = await dataURLFromFile(coverFile);
    const id = `${epubFile.name.replace(/\s+/g,'_')}_${Date.now()}`;
    const obj = {
      id,
      title: epubFile.name.replace(/\.(epub)$/i,''),
      epub: epubBlob,
      cover: coverData,
      lastCfi: ''
    };
    await saveSeries(obj);
    showStatus('Ready');
    epubInput.value = '';
    coverInput.value = '';
    await renderLibrary();
  }catch(err){
    console.error(err);
    alert('Failed to add series. See console for details.');
    showStatus('Ready');
  }
});
let currentSeriesId = null;
let book = null;
let rendition = null;
let currentBookBlobUrl = null;
function resetReader(){
  try{ if(rendition && rendition.destroy) rendition.destroy(); } catch(e){}
  rendition = null;
  book = null;
  if(currentBookBlobUrl){ URL.revokeObjectURL(currentBookBlobUrl); currentBookBlobUrl = null; }
  viewer.innerHTML = '';
  progressFill.style.height = '0%';
}
async function openSeries(id){
  showStatus('Loading book...');
  const s = await getSeriesById(id);
  if(!s || !s.epub){
    alert('Series or EPUB missing.');
    return;
  }
  resetReader();
  currentSeriesId = id;
  currentSeries = s;
  seriesTitle.textContent = s.title || 'Series';
  homepageView.style.display = 'none';
  readerWrap.style.display = 'flex';
  const epubBlob = s.epub;
  currentBookBlobUrl = URL.createObjectURL(epubBlob);
  try{
    showStatus('Initializing reader...');
    // CRITICAL FIX FOR EPUB.JS: Use blobUrl replacement so it reads from the Blob only!
    book = ePub({ replacements: 'blobUrl', url: currentBookBlobUrl });
    rendition = book.renderTo(viewer, {
      width: '100%',
      height: '100%',
      flow: 'scrolled'
    });
    rendition.themes.default({
      'body': {
        'color': 'var(--accent)',
        'background': 'transparent',
        'font-family': 'Playfair Display, serif',
        'line-height': '1.8'
      },
      'p': { 'font-size': '18px' }
    });
    await book.ready;
    if(!book.locations || !book.locations.length){
      try{ await book.locations.generate(1200); } catch(e){ console.warn('locations.generate failed',e); }
    }
    const startCfi = s.lastCfi && s.lastCfi.length ? s.lastCfi : undefined;
    await rendition.display(startCfi);
    rendition.on('rendered', (section) => {
      try{
        const doc = section.document || section.documentElement;
        if(!doc) return;
        setTimeout(()=>{
          const firstP = doc.querySelector('p');
          if(firstP){
            if(!firstP.querySelector('.dropcap')){
              const text = firstP.textContent.trim();
              if(text && text.length){
                const firstChar = text[0];
                firstP.innerHTML = `<span class="dropcap">${firstChar}</span>` + firstP.innerHTML.slice(1);
              }
            }
          }
        }, 120);
      }catch(e){
        console.warn('rendered handler error', e);
      }
    });
    rendition.on('relocated', (location) => {
      try{
        const cfi = location.start.cfi;
        let pct = 0;
        try{
          if(book.locations && book.locations.length){
            pct = Math.round(book.locations.percentageFromCfi(cfi) * 100);
          } else if(location.start && location.start.percentage){
            pct = Math.round(location.start.percentage * 100);
          }
        }catch(e){}
        progressFill.style.height = pct + '%';
        (async ()=>{
          try{
            const obj = await getSeriesById(currentSeriesId);
            if(obj){
              obj.lastCfi = cfi;
              await saveSeries(obj);
            }
          }catch(e){ console.warn('save lastCfi failed', e); }
        })();
      }catch(e){ console.warn(e); }
    });
    showStatus('Ready');
  }catch(err){
    console.error('openSeries error', err);
    alert('Failed to open EPUB. See console for details.');
    showStatus('Ready');
  }
}
nextBtn.addEventListener('click', ()=>{ if(rendition) { playFog(()=>rendition.next()); }});
prevBtn.addEventListener('click', ()=>{ if(rendition) { playFog(()=>rendition.prev()); }});
function playFog(action){
  fog.style.opacity = 1;
  setTimeout(()=>{
    try{ action(); }catch(e){ console.warn(e); }
    setTimeout(()=> fog.style.opacity = 0, 380);
  }, 220);
}
document.addEventListener('keydown', (e)=>{
  const tag = document.activeElement && document.activeElement.tagName.toLowerCase();
  if(tag === 'input' || tag === 'textarea') return;
  if(!rendition){
    return;
  }
  if(e.code === 'ArrowRight'){
    e.preventDefault();
    playFog(()=>rendition.next());
  } else if(e.code === 'ArrowLeft'){
    e.preventDefault();
    playFog(()=>rendition.prev());
  } else if(e.code === 'Space' || e.code === 'ArrowDown'){
    e.preventDefault();
    viewer.scrollBy({ top: 240, behavior: 'smooth' });
  } else if(e.code === 'ShiftRight' || e.code === 'ArrowUp'){
    e.preventDefault();
    viewer.scrollBy({ top: -240, behavior: 'smooth' });
  }
});
gotoHomeBtn.addEventListener('click', ()=>{
  resetReader();
  readerWrap.style.display = 'none';
  homepageView.style.display = 'block';
  renderLibrary();
});
downloadEpubBtn.addEventListener('click', async ()=>{
  if(!currentSeriesId) return;
  try{
    const s = await getSeriesById(currentSeriesId);
    if(s && s.epub){
      downloadBlob(s.epub, (s.title || 'book') + '.epub');
    }else alert('EPUB not available.');
  }catch(e){ console.error(e); alert('Download failed.'); }
});
(async function init(){
  try{
    await openDB();
    await renderLibrary();
    showStatus('Ready');
  }catch(e){
    console.error('Init error', e);
    showStatus('Error');
  }
})();
</script>
</body>
</html>
