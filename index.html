<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Comick — Final Reader</title>
<script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
<style>
:root{--bg:#0d0d0f;--panel:#121216;--muted:#9b9b9b;--accent:#f5f5dc}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:'Playfair Display',serif;background:var(--bg);color:var(--accent);-webkit-font-smoothing:antialiased}
#app{display:flex;min-height:100vh}

/* Sidebar */
#sidebar{width:340px;padding:24px;background:linear-gradient(180deg,#0b0b0d,#0f0f12);border-right:1px solid rgba(255,255,255,0.03)}
h1{margin:0 0 12px 0;font-size:20px}
.controls{display:flex;flex-direction:column;gap:8px;margin-bottom:12px}
.upload-row{display:flex;gap:8px;align-items:center}
.input-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer;display:inline-flex;align-items:center}
.small{font-size:13px;color:var(--muted)}
.action-row{display:flex;gap:8px;align-items:center}

/* Tiles */
.tiles{display:flex;flex-wrap:wrap;gap:14px;margin-top:12px}
.tile{width:160px;height:240px;border-radius:10px;overflow:hidden;position:relative;background:#171718;box-shadow:0 6px 18px rgba(0,0,0,0.6);cursor:pointer;transition:transform .18s,box-shadow .18s,filter .18s}
.tile img{width:100%;height:100%;object-fit:cover;display:block}
.tile .meta{position:absolute;left:0;right:0;bottom:0;padding:8px;background:linear-gradient(180deg,transparent, rgba(0,0,0,0.65));display:flex;justify-content:center}
.tile:hover{transform:translateY(-6px) scale(1.05);box-shadow:0 18px 48px rgba(245,245,220,0.35);filter:brightness(1.08)}

/* Main / Reader */
#main{flex:1;padding:24px;display:flex;flex-direction:column;align-items:center}
.header-row{width:100%;display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
#readerWrap{display:none;width:100%;height:100vh;position:relative}
#readerHeader{width:100%;display:flex;justify-content:space-between;align-items:center;padding:16px 24px;position:fixed;top:0;left:0;z-index:40;background:linear-gradient(180deg, rgba(10,10,10,0.92), transparent)}
#viewerContainer{width:880px;max-width:94%;margin-top:82px;margin-bottom:84px;height:calc(100vh - 160px)}
#viewer{background:rgba(0,0,0,0.92);border-radius:12px;padding:28px;box-shadow:0 12px 40px rgba(0,0,0,0.6);width:100%;height:100%;overflow:auto;color:var(--accent)}
#viewer *{color:inherit}
.footer-controls{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:center;gap:12px;pointer-events:none}
.btn{pointer-events:auto;background:linear-gradient(145deg,#2a2a2a,#171717);border-radius:28px;padding:10px 16px;border:none;color:var(--accent);cursor:pointer;box-shadow:0 8px 28px rgba(0,0,0,0.5)}
.progressBarWrap{position:fixed;right:18px;top:18px;width:12px;height:52vh;background:rgba(255,255,255,0.03);border-radius:18px;overflow:hidden}
.progressFill{width:100%;height:0;background:linear-gradient(180deg,var(--accent),#d4d4b8)}

/* Cursor orb */
#cursorGlow{position:fixed;width:12px;height:12px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;box-shadow:0 0 18px 7px rgba(245,245,220,0.6);transform:translate(-50%,-50%);z-index:9999;transition:all .12s ease}

/* responsive */
@media (max-width:980px){#sidebar{display:none}#viewerContainer{width:96%}}
</style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h1>Comick Library</h1>

    <div class="controls">
      <div class="upload-row">
        <label class="input-btn">EPUB<input id="epubInput" type="file" accept=".epub" style="display:none"></label>
        <label class="input-btn">Cover<input id="coverInput" type="file" accept="image/*" style="display:none"></label>
        <button id="addSeriesBtn" class="input-btn">Add</button>
      </div>

      <div class="action-row">
        <button id="clearAllBtn" class="input-btn">Clear All</button>
        <div id="statusMsg" class="small" style="margin-left:8px">Ready</div>
      </div>
    </div>

    <div class="small">Library (click to open • right-click to delete)</div>
    <div class="tiles" id="tiles"></div>
  </aside>

  <main id="main">
    <div class="header-row">
      <h2 style="margin:0">Your Library</h2>
      <div class="small">Click a tile to open. Right-click to delete. Progress saved automatically.</div>
    </div>

    <div id="readerWrap">
      <div id="readerHeader">
        <div id="seriesTitle">Series</div>
        <div style="display:flex;gap:8px;">
          <button id="gotoHome" class="btn">Library</button>
          <button id="downloadEpub" class="btn">Download</button>
        </div>
      </div>

      <div id="viewerContainer"><div id="viewer" tabindex="0"></div></div>

      <div class="footer-controls">
        <button id="prevBtn" class="btn">⟵ Prev</button>
        <button id="nextBtn" class="btn">Next ⟶</button>
      </div>

      <div class="progressBarWrap" title="Reading progress"><div class="progressFill" id="progressFill"></div></div>
    </div>
  </main>
</div>

<div id="cursorGlow"></div>

<script>
document.addEventListener('DOMContentLoaded', ()=>{

  // Elements
  const statusMsg = document.getElementById('statusMsg');
  const tilesDiv = document.getElementById('tiles');
  const epubInput = document.getElementById('epubInput');
  const coverInput = document.getElementById('coverInput');
  const addSeriesBtn = document.getElementById('addSeriesBtn');
  const clearAllBtn = document.getElementById('clearAllBtn');
  const readerWrap = document.getElementById('readerWrap');
  const viewer = document.getElementById('viewer');
  const seriesTitle = document.getElementById('seriesTitle');
  const gotoHome = document.getElementById('gotoHome');
  const downloadEpub = document.getElementById('downloadEpub');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const progressFill = document.getElementById('progressFill');

  // Cursor orb - follows immediately; amplify on hover via delegation
  const cursorGlow = document.getElementById('cursorGlow');
  document.addEventListener('mousemove', e=>{
    cursorGlow.style.left = e.clientX + 'px';
    cursorGlow.style.top = e.clientY + 'px';
  });
  document.addEventListener('mouseover', e=>{
    if (e.target.closest('.input-btn') || e.target.closest('.tile') || e.target.closest('.btn')) {
      cursorGlow.style.boxShadow = '0 0 28px 12px rgba(245,245,220,0.95)';
      cursorGlow.style.transform = 'translate(-50%,-50%) scale(1.4)';
    }
  });
  document.addEventListener('mouseout', e=>{
    if (e.target.closest('.input-btn') || e.target.closest('.tile') || e.target.closest('.btn')) {
      cursorGlow.style.boxShadow = '0 0 18px 7px rgba(245,245,220,0.6)';
      cursorGlow.style.transform = 'translate(-50%,-50%) scale(1)';
    }
  });

  /* ---------------- IndexedDB (robust) ---------------- */
  const DB = 'comick_final_v1';
  const STORE = 'series';
  let dbPromise = null;

  function openDB(){
    if (dbPromise) return dbPromise;
    dbPromise = new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB,1);
      req.onupgradeneeded = (e)=>{
        const idb = e.target.result;
        if (!idb.objectStoreNames.contains(STORE)) idb.createObjectStore(STORE,{keyPath:'id'});
      };
      req.onsuccess = e => resolve(e.target.result);
      req.onerror = e => reject(e);
    });
    return dbPromise;
  }

  async function saveSeries(obj){
    const db = await openDB();
    return new Promise((res, rej)=>{
      const tx = db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).put(obj);
      tx.oncomplete = ()=>res();
      tx.onerror = (e)=>rej(e);
    });
  }
  async function getAllSeries(){
    const db = await openDB();
    return new Promise((res,rej)=>{
      const tx = db.transaction(STORE,'readonly');
      const req = tx.objectStore(STORE).getAll();
      req.onsuccess = ()=>res(req.result || []);
      req.onerror = ()=>res([]);
    });
  }
  async function deleteSeriesById(id){
    const db = await openDB();
    return new Promise((res,rej)=>{
      const tx = db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).delete(id);
      tx.oncomplete = ()=>res();
      tx.onerror = (e)=>rej(e);
    });
  }
  async function clearAll(){
    const db = await openDB();
    return new Promise((res,rej)=>{
      const tx = db.transaction(STORE,'readwrite');
      tx.objectStore(STORE).clear();
      tx.oncomplete = ()=>res();
      tx.onerror = (e)=>rej(e);
    });
  }

  /* ---------------- Upload workflow ---------------- */
  let selectedEpub = null;
  let selectedCover = null;

  epubInput.addEventListener('change', e=>{
    selectedEpub = e.target.files && e.target.files[0] ? e.target.files[0] : null;
    statusMsg.textContent = selectedEpub ? 'EPUB selected: ' + selectedEpub.name : 'Choose EPUB';
  });

  coverInput.addEventListener('change', e=>{
    selectedCover = e.target.files && e.target.files[0] ? e.target.files[0] : null;
    statusMsg.textContent = selectedCover ? 'Cover selected: ' + selectedCover.name : statusMsg.textContent;
  });

  addSeriesBtn.addEventListener('click', async ()=>{
    try {
      if (!selectedEpub) { alert('Select an EPUB first'); return; }
      const id = Date.now().toString() + '-' + Math.floor(Math.random()*10000);
      const title = selectedEpub.name.replace(/\.epub$/i,'');
      const entry = { id, title, epubBlob: selectedEpub, coverBlob: selectedCover || null, lastLocationCfi: null };
      await saveSeries(entry);
      selectedEpub = null; selectedCover = null; epubInput.value=''; coverInput.value='';
      statusMsg.textContent = 'Saved: ' + title;
      await renderLibrary();
    } catch (err) {
      console.error('save error', err);
      statusMsg.textContent = 'Save failed (console)';
    }
  });

  clearAllBtn.addEventListener('click', async ()=>{
    if (!confirm('Clear entire library? This cannot be undone.')) return;
    try {
      await clearAll();
      statusMsg.textContent = 'Library cleared';
      await renderLibrary();
    } catch (err) {
      console.error(err);
      statusMsg.textContent = 'Clear failed';
    }
  });

  /* ---------------- Render tiles ---------------- */
  async function renderLibrary(){
    tilesDiv.innerHTML = '';
    try {
      const list = await getAllSeries();
      if (!list || list.length === 0) {
        tilesDiv.innerHTML = '<div class="small" style="padding:12px;color:var(--muted)">No series yet. Add one above.</div>';
        return;
      }
      for (const s of list) {
        const tile = document.createElement('div'); tile.className = 'tile';
        const img = document.createElement('img');
        if (s.coverBlob) {
          img.src = URL.createObjectURL(s.coverBlob);
        } else {
          // simple generated SVG placeholder
          img.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='320' height='480'><rect fill='#141414' width='100%' height='100%'/><text x='50%' y='50%' fill='#bdbdb4' font-family='serif' font-size='20' text-anchor='middle'>No Cover</text></svg>`);
        }
        tile.appendChild(img);
        const meta = document.createElement('div'); meta.className='meta';
        const title = document.createElement('div'); title.className='title'; title.textContent = s.title || 'Untitled';
        meta.appendChild(title); tile.appendChild(meta);

        // click open
        tile.addEventListener('click', ()=> openReader(s));

        // right click delete
        tile.addEventListener('contextmenu', async (ev)=>{
          ev.preventDefault();
          if (!confirm('Delete "' + (s.title||'Untitled') + '"?')) return;
          try {
            await deleteSeriesById(s.id);
            statusMsg.textContent = 'Deleted: ' + (s.title||s.id);
            await renderLibrary();
          } catch (err) {
            console.error(err); statusMsg.textContent = 'Delete failed';
          }
        });

        tilesDiv.appendChild(tile);
      }
    } catch (err) {
      console.error(err);
      statusMsg.textContent = 'Failed to render library';
    }
  }

  /* --------------- EPUB rendering & persistence --------------- */
  let currentSeries = null;
  let currentBook = null;
  let currentRendition = null;
  let currentBlobUrl = null;

  async function cleanupRendition(){
    try {
      if (currentRendition && typeof currentRendition.destroy === 'function') {
        try { currentRendition.destroy(); } catch(e){/*ignore*/}
      }
    } catch(e){}
    currentRendition = null;

    try {
      if (currentBook && typeof currentBook.destroy === 'function') {
        try { currentBook.destroy(); } catch(e){/*ignore*/}
      }
    } catch(e){}
    currentBook = null;

    if (currentBlobUrl) {
      try { URL.revokeObjectURL(currentBlobUrl); } catch(e){}
    }
    currentBlobUrl = null;
    viewer.innerHTML = '';
    progressFill.style.height = '0%';
  }

  // compute progress percent: try using location.start.percentage from relocated event; fallback to viewer scroll
  function setProgressFromRelocated(loc){
    try {
      if (loc && loc.start && typeof loc.start.percentage === 'number') {
        const p = Math.round(loc.start.percentage * 100);
        progressFill.style.height = p + '%';
        return;
      }
    } catch(e){}
    // fallback: scroll percent
    try {
      const total = viewer.scrollHeight - viewer.clientHeight;
      if (total > 0) {
        const p = Math.min(100, Math.round((viewer.scrollTop / total) * 100));
        progressFill.style.height = p + '%';
      } else {
        progressFill.style.height = '0%';
      }
    } catch(e){}
  }

  async function openReader(seriesObj){
    await cleanupRendition();
    try {
      currentSeries = seriesObj;
      document.querySelector('.header-row').style.display = 'none';
      readerWrap.style.display = 'block';
      seriesTitle.textContent = currentSeries.title || 'Series';

      // create URL & book
      currentBlobUrl = URL.createObjectURL(currentSeries.epubBlob);
      currentBook = ePub(currentBlobUrl);

      // wait book ready
      await currentBook.ready;

      // generate locations if not present to enable percentage progress (best-effort)
      if (!currentBook.locations || !currentBook.locations.length) {
        try {
          await currentBook.locations.generate(2000); // generate locations; may be async/slow for huge books
        } catch(e){ /* ignore */ }
      }

      // render into viewer
      currentRendition = currentBook.renderTo('viewer', { width:'100%', height:'100%' });

      // theme: ensure readable
      currentRendition.themes.register('comick-dark',{
        'body': {
          'color':'var(--accent)',
          'background':'#070707',
          'font-family':'Playfair Display, serif',
          'line-height':'1.6',
          'padding':'0 0'
        },
        'p': {'color':'var(--accent)'}
      });
      currentRendition.themes.select('comick-dark');

      // relocated event for progress + save last location
      currentRendition.on('relocated', async (loc) => {
        setProgressFromRelocated(loc);
        try {
          // save last CFI in DB for resume
          const dbEntry = await getSeriesById(currentSeries.id);
          if (dbEntry) {
            dbEntry.lastLocationCfi = (loc && loc.start && loc.start.cfi) ? loc.start.cfi : null;
            await saveSeries(dbEntry);
          }
        } catch(e){ console.warn('save last loc failed', e); }
      });

      // rendered event: visible content
      let renderedOnce = false;
      currentRendition.on('rendered', section => {
        if (!renderedOnce) {
          renderedOnce = true;
          statusMsg.textContent = 'Rendered: ' + (currentSeries.title || '');
        }
      });

      // display either saved location or start
      const wantCfi = currentSeries.lastLocationCfi || null;
      if (wantCfi) {
        try {
          await currentRendition.display(wantCfi);
        } catch(e){
          // fallback to default display
          try { await currentRendition.display(); } catch(e2){ console.warn(e2); }
        }
      } else {
        try { await currentRendition.display(); } catch(e){ console.warn(e); }
      }

      // guard: if viewer empty after short delay, try a second display
      setTimeout(async ()=>{
        try {
          const txt = viewer.innerText || '';
          if (txt.trim().length === 0) {
            try { await currentRendition.display(); } catch(e){/*ignore*/}
          }
        } catch(e){}
      }, 80);

      statusMsg.textContent = 'Open: ' + (currentSeries.title || '');
    } catch (err) {
      console.error('openReader failed', err);
      statusMsg.textContent = 'Failed to open EPUB (check console)';
      await cleanupRendition();
    }
  }

  async function getSeriesById(id){
    try {
      const db = await openDB();
      return new Promise((res,rej)=>{
        const tx = db.transaction(STORE,'readonly');
        const req = tx.objectStore(STORE).get(id);
        req.onsuccess = ()=>res(req.result);
        req.onerror = ()=>res(null);
      });
    } catch(e){ return null; }
  }

  // prev / next
  async function goPrev(){
    try {
      if (!currentRendition) return;
      await currentRendition.prev();
    } catch(e){ console.warn(e); }
  }
  async function goNext(){
    try {
      if (!currentRendition) return;
      await currentRendition.next();
    } catch(e){ console.warn(e); }
  }

  prevBtn.addEventListener('click', goPrev);
  nextBtn.addEventListener('click', goNext);

  gotoHome.addEventListener('click', async ()=>{
    await cleanupRendition();
    readerWrap.style.display = 'none';
    document.querySelector('.header-row').style.display = 'flex';
  });

  downloadEpub.addEventListener('click', ()=>{
    if (!currentSeries) return;
    const link = document.createElement('a');
    link.href = URL.createObjectURL(currentSeries.epubBlob);
    link.download = (currentSeries.title || 'download') + '.epub';
    document.body.appendChild(link);
    link.click();
    link.remove();
    setTimeout(()=>{ try{ URL.revokeObjectURL(link.href) }catch(e){} }, 5000);
  });

  // helper: render library initially
  renderLibrary();

}); // DOMContentLoaded
</script>
</body>
</html>
