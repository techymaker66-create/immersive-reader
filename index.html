<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Comick-style Immersive Reader</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
  <style>
    :root{
      --bg:#0d0d0f; --panel:#121216; --muted:#9b9b9b; --accent:#f5f5dc;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:'Playfair Display',serif;background:var(--bg);color:var(--accent);}

    /* --- Homepage --- */
    #app{display:flex;min-height:100vh}
    #sidebar{width:320px;padding:28px;background:linear-gradient(180deg,#0b0b0d, #0f0f12);border-right:1px solid rgba(255,255,255,0.03);}
    #main{flex:1;padding:28px;display:flex;flex-direction:column;align-items:center;}

    h1{margin:0 0 12px 0;font-size:20px;letter-spacing:1px}
    .controls{margin:12px 0 22px 0}
    input[type=file]{display:block;margin-bottom:10px}
    .add-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--accent);cursor:pointer}

    .tiles{display:flex;flex-wrap:wrap;gap:18px}
    .tile{width:160px; height:240px; border-radius:10px; overflow:hidden; position:relative; background:#18181a; box-shadow:0 6px 18px rgba(0,0,0,0.6); cursor:pointer; transition:transform .25s,box-shadow .25s}
    .tile img{width:100%;height:100%;object-fit:cover;display:block}
    .tile:hover{transform:translateY(-6px) scale(1.02); box-shadow:0 12px 30px rgba(0,0,0,0.7)}
    .tile .meta{position:absolute;left:0;right:0;bottom:0;padding:10px;background:linear-gradient(180deg,transparent, rgba(0,0,0,0.6));display:flex;justify-content:space-between;align-items:center}
    .tile .meta .title{font-size:13px}
    .tile .meta .resume{font-size:12px;color:var(--muted)}

    /* --- Reader --- */
    #readerWrap{display:none;flex-direction:column;align-items:center;position:relative;width:100%;height:100vh}
    #readerHeader{width:100%;display:flex;justify-content:space-between;align-items:center;padding:22px 40px;position:fixed;top:0;left:0;z-index:50;background:linear-gradient(180deg, rgba(10,10,10,0.9), transparent);backdrop-filter: blur(2px)}
    #readerHeader h2{margin:0;font-size:18px}
    #viewerContainer{width:820px;max-width:92%;margin-top:98px;margin-bottom:80px;position:relative}
    #viewer{background:rgba(0,0,0,0.35);padding:36px 48px;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.7);max-height:74vh;overflow:auto}
    #viewer .chapter-title{font-size:20px;margin:0 0 12px 0}
    #viewer p{opacity:0;margin:0 0 1.15em 0;line-height:1.8;font-size:18px}
    #viewer p.visible{opacity:1;transition:opacity .8s ease}
    #viewer .dropcap{float:left;font-size:64px;line-height:56px;padding-right:12px;padding-top:8px;color:var(--accent)}

    /* Progress bar */
    #progressBar{position:fixed;right:20px;top:20px;width:10px;height:60vh;background:rgba(255,255,255,0.03);border-radius:20px;overflow:hidden}
    #progressFill{width:100%;height:0;background:linear-gradient(180deg,var(--accent), #d4d4b8)}

    /* Nav buttons */
    .nav{position:fixed;left:0;right:0;bottom:24px;display:flex;justify-content:space-between;padding:0 40px;pointer-events:none}
    .nav button{pointer-events:auto;background:linear-gradient(145deg,#2a2a2a,#171717);border-radius:28px;padding:14px 22px;border:none;color:var(--accent);font-size:16px;box-shadow:0 8px 22px rgba(0,0,0,0.6);cursor:pointer;transition:transform .18s,box-shadow .18s}
    .nav button:hover{transform:scale(1.06);box-shadow:0 14px 34px rgba(0,0,0,0.75)}
    .nav button:active{transform:scale(.96)}

    /* Fog overlay for transitions */
    #fog{position:fixed;inset:0;background:radial-gradient(circle at 50% 40%, rgba(255,255,255,0.02), rgba(255,255,255,0.01) 10%, rgba(0,0,0,0.85) 40%);pointer-events:none;opacity:0;transition:opacity .6s;z-index:90}

    /* Cursor glow */
    #cursorGlow{position:fixed;width:14px;height:14px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;box-shadow:0 0 22px 6px rgba(245,245,220,0.12);transform:translate(-50%,-50%);z-index:200}

    /* Mobile tweaks */
    @media (max-width:900px){#sidebar{display:none}#viewer{padding:22px}}
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h1>Comick Library</h1>
      <div class="controls">
        <label class="add-btn">Add Series (EPUB)
          <input id="epubInput" type="file" accept=".epub" style="display:none">
        </label>
        <button id="addSeriesBtn" class="add-btn">Add Series</button>
      </div>
      <div id="instructions" style="color:var(--muted);font-size:13px;line-height:1.5">
        <strong>Quick guide</strong><br>
        • Upload an EPUB and then upload a cover when prompted.<br>
        • Click a cover tile to open reader. Your progress auto-saves.<br>
        • Keyboard: Space/Down = scroll down; RightShift = scroll up; Left/Right = prev/next chapter.<br>
        • All data stored locally in your browser (no server required).
      </div>
      <div style="height:24px"></div>
      <div style="color:var(--muted);font-size:13px;">Series stored in browser. Back up EPUBs if needed.</div>
    </aside>

    <main id="main">
      <div id="homepageView">
        <div style="width:100%;display:flex;justify-content:space-between;align-items:center;margin-bottom:18px">
          <h2 style="margin:0">Your Library</h2>
          <div style="color:var(--muted);font-size:13px">Tap a cover to open • Hover to resume</div>
        </div>
        <div class="tiles" id="tiles"></div>
      </div>

      <div id="readerWrap">
        <div id="readerHeader">
          <h2 id="seriesTitle">Series</h2>
          <div>
            <button id="gotoHome" class="add-btn">Library</button>
            <button id="downloadEpub" class="add-btn">Download EPUB</button>
          </div>
        </div>

        <div id="viewerContainer">
          <div id="viewer" tabindex="0"></div>
        </div>

        <div id="progressBar"><div id="progressFill"></div></div>

        <div class="nav">
          <button id="prevBtn">⟵ Prev</button>
          <button id="nextBtn">Next ⟶</button>
        </div>
      </div>

    </main>
  </div>

  <div id="fog"></div>
  <div id="cursorGlow"></div>

  <script>
  // Brutally honest: This is a full client-side prototype. Nothing is uploaded to servers by default.
  // You must keep your EPUBs backed up; localStorage can be cleared by cleaning browser data.

  // Utilities for localStorage
  const LS_KEY = 'comick_series_v1';
  function loadSeriesMap(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch(e){ return {}; }}
  function saveSeriesMap(m){ localStorage.setItem(LS_KEY, JSON.stringify(m)); }

  const tiles = document.getElementById('tiles');
  const epubInput = document.getElementById('epubInput');
  const addSeriesBtn = document.getElementById('addSeriesBtn');
  const viewer = document.getElementById('viewer');
  const readerWrap = document.getElementById('readerWrap');
  const homepageView = document.getElementById('homepageView');
  const seriesTitle = document.getElementById('seriesTitle');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const gotoHome = document.getElementById('gotoHome');
  const fog = document.getElementById('fog');
  const progressFill = document.getElementById('progressFill');
  const downloadEpub = document.getElementById('downloadEpub');

  const cursorGlow = document.getElementById('cursorGlow');
  document.addEventListener('mousemove', (e)=>{
    cursorGlow.style.left = e.clientX + 'px';
    cursorGlow.style.top = e.clientY + 'px';
  });

  // Render saved series
  let seriesMap = loadSeriesMap();
  function renderTiles(){ tiles.innerHTML='';
    for(const id in seriesMap){ const s = seriesMap[id];
      const el = document.createElement('div'); el.className='tile'; el.dataset.id=id;
      const img = document.createElement('img'); img.src=s.cover; el.appendChild(img);
      const meta = document.createElement('div'); meta.className='meta';
      const title = document.createElement('div'); title.className='title'; title.textContent=s.title||'Untitled';
      const resume = document.createElement('div'); resume.className='resume'; resume.textContent = s.lastCfi ? `Chapter saved` : 'New';
      meta.appendChild(title); meta.appendChild(resume); el.appendChild(meta);
      el.addEventListener('click', ()=> openSeries(id));
      tiles.appendChild(el);
    }
  }
  renderTiles();

  // Add series flow
  addSeriesBtn.addEventListener('click', ()=> epubInput.click());
  epubInput.addEventListener('change', async (ev)=>{
    const file = ev.target.files[0]; if(!file) return;
    const name = file.name.replace(/\.epub$/i,'');
    // ask for a cover
    const cover = await askForCover(name);
    const url = URL.createObjectURL(file);
    const id = 's_'+Date.now();
    // read file into base64 for persistence (note: large epub base64 can be big; it's stored locally)
    const base64 = await fileToBase64(file);
    seriesMap[id] = { title: name, cover: cover, epubBase64: base64, lastCfi: null };
    saveSeriesMap(seriesMap); renderTiles();
    alert('Series added. Click its cover to open.');
    epubInput.value='';
  });

  function askForCover(seriesName){
    return new Promise((resolve)=>{
      const inp = document.createElement('input'); inp.type='file'; inp.accept='image/*';
      inp.onchange = async (e)=>{
        const f = e.target.files[0]; if(!f){ resolve(defaultCover(seriesName)); return; }
        const b = await fileToBase64(f); resolve(b);
      };
      inp.click();
    });
  }
  function defaultCover(name){ // simple fallback cover as data URI (SVG)
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='800' height='1200'><rect width='100%' height='100%' fill='#111'/><text x='50%' y='50%' font-size='40' fill='#e6e0c8' text-anchor='middle' font-family='Playfair Display'>${escapeHtml(name)}</text></svg>`;
    return 'data:image/svg+xml;utf8,'+encodeURIComponent(svg);
  }
  function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function fileToBase64(file){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(file); }); }

  // Reader state
  let currentSeries = null;
  let book = null; let rendition = null;

  async function openSeries(id){
    const s = seriesMap[id]; if(!s) return; currentSeries = { id, ...s };
    homepageView.style.display='none'; readerWrap.style.display='flex';
    seriesTitle.textContent = s.title;

    // prepare epub blob
    const blob = dataURLtoBlob(s.epubBase64);
    const blobURL = URL.createObjectURL(blob);

    // initialize ePub
    if(rendition) { try { await rendition.destroy(); } catch(e){} }
    book = ePub(blobURL);
    rendition = book.renderTo(viewer, { flow:'scrolled-doc', width:'100%', height:'100%' });
    // apply simple CSS for body inside epub
    rendition.themes.default({ 'body': { 'color': 'var(--accent)', 'background': 'transparent', 'font-family': 'Playfair Display, serif', 'line-height':'1.8' } });

    // display first or saved CFI
    const saved = seriesMap[id].lastCfi;
    try{
      await book.ready;
      await book.locations.generate(1024);
    }catch(e){ /* ignore */ }

    await rendition.display(saved || undefined);

    // paragraph fade-in: observe loaded content nodes
    setupParagraphObserver();

    // update progress on relocation
    rendition.on('relocated', (loc)=>{
      try{ const percentage = book.locations.percentageFromCfi(loc.start.cfi) || 0; updateProgress(percentage); seriesMap[currentSeries.id].lastCfi = loc.start.cfi; saveSeriesMap(seriesMap); updateTabTitle(); }catch(e){}
    });

    // also update when user scrolls inside viewer
    viewer.addEventListener('scroll', onViewerScroll);

    // download link
    downloadEpub.onclick = ()=> downloadDataURL(s.epubBase64, s.title+'.epub');
  }

  function updateTabTitle(){ if(!currentSeries) return; const id=currentSeries.id; const s=seriesMap[id]; const cfi = s.lastCfi; let ch=''; try{ ch = book.locations && book.locations.cfiFromPercentage ? Math.round(book.locations.percentageFromCfi(cfi)*100) : ''; }catch(e){} document.title = `${s.title} — ${ch? 'Progress '+ch+'%':''}`; }

  function updateProgress(p){ progressFill.style.height = (p*100)+'%'; }

  function onViewerScroll(){ // compute percentage based on scrollTop / scrollHeight
    const el = viewer; const pct = el.scrollTop / (el.scrollHeight - el.clientHeight); if(isFinite(pct)) updateProgress(pct);
    // save approximate cfi by asking current location: ask rendition.currentLocation
    try{ const loc = rendition.currentLocation(); if(loc && loc.start && loc.start.cfi){ seriesMap[currentSeries.id].lastCfi = loc.start.cfi; saveSeriesMap(seriesMap); } }catch(e){}
  }

  function setupParagraphObserver(){
    // show paragraphs that are in viewport
    const showVisible = ()=>{
      Array.from(viewer.querySelectorAll('p')).forEach(p=>{
        const r = p.getBoundingClientRect();
        const containerRect = viewer.getBoundingClientRect();
        if(r.top < containerRect.bottom - 40 && r.bottom > containerRect.top + 40){ p.classList.add('visible'); } else { /* keep visible if already shown */ }
      });
    };
    // small debounce
    let t; viewer.addEventListener('scroll', ()=>{ clearTimeout(t); t=setTimeout(showVisible, 80); });
    // initial
    setTimeout(showVisible, 300);
  }

  // Fog transition for chapter flips
  function playFogAnd(fn){ fog.style.opacity=1; setTimeout(()=>{ try{ fn(); }catch(e){} setTimeout(()=> fog.style.opacity=0, 450); }, 280); }

  // Prev/Next handlers
  prevBtn.addEventListener('click', ()=>{ if(!rendition) return; playFogAnd(()=> rendition.prev()); });
  nextBtn.addEventListener('click', ()=>{ if(!rendition) return; playFogAnd(()=> rendition.next()); });

  // Keyboard controls
  document.addEventListener('keydown',(e)=>{
    const tag = document.activeElement.tagName.toLowerCase(); if(tag==='input' || tag==='textarea') return;
    if(e.code==='Space' || e.code==='ArrowDown'){ e.preventDefault(); // scroll down
      viewer.scrollBy({top:220, behavior:'smooth'});
    } else if(e.code==='ShiftRight'){ e.preventDefault(); viewer.scrollBy({top:-220, behavior:'smooth'});
    } else if(e.code==='ArrowRight'){ e.preventDefault(); playFogAnd(()=> rendition && rendition.next());
    } else if(e.code==='ArrowLeft'){ e.preventDefault(); playFogAnd(()=> rendition && rendition.prev()); }
  });

  // Home button
  gotoHome.addEventListener('click', ()=>{ closeReader(); });
  function closeReader(){ viewer.removeEventListener('scroll', onViewerScroll); viewer.innerHTML=''; readerWrap.style.display='none'; homepageView.style.display='block'; currentSeries=null; book=null; rendition=null; updateTabTitle(); }

  // helper: dataURL to Blob
  function dataURLtoBlob(dataurl){ const parts = dataurl.split(','); const mime = parts[0].match(/:(.*?);/)[1]; const bstr = atob(parts[1]); let n = bstr.length; const u8arr = new Uint8Array(n); while(n--) u8arr[n] = bstr.charCodeAt(n); return new Blob([u8arr], {type:mime}); }

  // helper: download base64 dataurl
  function downloadDataURL(dataUrl, filename){ const a=document.createElement('a'); a.href=dataUrl; a.download=filename; document.body.appendChild(a); a.click(); a.remove(); }

  // small utility to populate demo if none
  (function seedDemo(){ if(Object.keys(seriesMap).length) return; // do nothing if user has series
    // intentionally not adding any copyrighted content. user should add EPUBs themselves.
  })();

  // Save before unload
  window.addEventListener('beforeunload', ()=>{ saveSeriesMap(seriesMap); });

  // Allow clicking tiles to open
  function downloadAllToTest(){ /* placeholder */ }

  // Expose for debugging
  window.__comick = { seriesMap, renderTiles };
  </script>
</body>
</html>
