<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Comick — Professional Reader (Restored Final)</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Merriweather:wght@300;400;700&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<style>
:root{
  --bg:#09090b;--panel:#0f0f12;--muted:#9b9b9b;--accent:#efe7c9;--glass:rgba(255,255,255,0.03);
  --card-shadow:0 24px 80px rgba(0,0,0,0.7);--btn-shadow:0 12px 36px rgba(0,0,0,0.55);
  --radius:14px;--measure:64ch;
  --reader-max:1100px; --reader-padding:44px;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#050505);color:var(--accent);-webkit-font-smoothing:antialiased;font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}

/* layout like your original */
#app{display:flex;min-height:100vh}
/* sidebar */
#sidebar{width:340px;padding:22px;background:linear-gradient(180deg,#070708,var(--panel));border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px}
#sidebar h1{margin:0;font-family:'Playfair Display',serif;font-size:20px}
.controls{display:flex;flex-direction:column;gap:10px}
.add-btn{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.04);color:var(--accent);cursor:pointer;transition:transform .14s ease,box-shadow .14s;box-shadow:var(--btn-shadow);font-weight:600}
.add-btn input{display:none}
.add-btn:hover{transform:translateY(-6px);box-shadow:0 20px 50px rgba(0,0,0,0.7)}
#statusMsg{color:var(--muted);font-size:13px}
.tiles{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:16px;margin-top:8px}

/* tile */
.tile{border-radius:12px;overflow:hidden;position:relative;background:#0e0e10;cursor:pointer;transition:transform .18s,box-shadow .18s;min-height:220px}
.tile img{width:100%;height:100%;object-fit:cover;aspect-ratio:2/3;display:block}
.tile .meta{position:absolute;left:0;right:0;bottom:0;padding:10px;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.72));display:flex;justify-content:space-between;align-items:center}
.tile:hover{transform:translateY(-8px) scale(1.02);box-shadow:0 28px 68px rgba(0,0,0,0.72)}
.tile .title{font-size:13px}
.tile .resume{font-size:12px;color:var(--muted)}

/* main */
#main{flex:1;padding:22px;display:flex;flex-direction:column;align-items:center;position:relative}
#homepageView{width:100%;max-width:1400px}
.headerRow{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.headerRow h2{margin:0;font-family:'Playfair Display',serif}

/* LIBRARY grid (keeps original look) */
.libraryGrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:20px;width:100%}

/* READER overlay (restored visual, but larger) */
#readerWrap{
  display:none;
  position:fixed;
  inset:56px 24px 24px 24px;
  z-index:1500;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}
#readerCard{
  width:100%;
  max-width:var(--reader-max);
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
  padding:var(--reader-padding);
  border-radius:12px;
  box-shadow:var(--card-shadow);
  overflow:hidden;
  pointer-events:auto;
  display:flex;
  flex-direction:column;
  max-height:calc(100% - 96px);
}
#readerHeader{height:66px;display:flex;align-items:center;justify-content:space-between;padding:6px 12px 18px 12px;background:transparent;flex:0 0 auto}
#readerHeader h2{margin:0;font-family:'Playfair Display',serif;font-size:18px}

/* viewer is isolated scroller; hide native scrollbar visually */
#viewerContainer{width:100%;flex:1;display:flex;align-items:stretch;justify-content:center}
#viewer{
  width:100%;
  max-width:var(--reader-max);
  background:transparent;
  padding:0;
  overflow:auto;
  scroll-behavior:smooth;
  -ms-overflow-style:none;
  scrollbar-width:none;
}
#viewer::-webkit-scrollbar{width:0;height:0}

/* inner reading card (paper-like) - wider than before and centered */
#viewerInner{
  background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.004));
  padding:32px;
  border-radius:12px;
  box-shadow:0 24px 80px rgba(0,0,0,0.6);
  width:100%;
  max-width:calc(var(--reader-max) - 2 * 32px);
  max-height:calc(100vh - 220px);
  margin:0 auto;
}

/* chapter card */
.chapter{margin:28px 0;padding:0;border-radius:12px;background:transparent;opacity:0;transform:translateY(12px)}
.chapter.visible{opacity:1;transform:translateY(0);transition:all .45s cubic-bezier(.2,.9,.2,1)}
.chapter-title{font-family:'Playfair Display',serif;font-size:20px;margin:0 0 12px 0;color:var(--accent)}
.chapter-body{max-width:var(--measure);margin:0 auto;color:var(--accent);font-size:18px;line-height:1.82;text-align:justify;hyphens:auto}
.chapter-body p{opacity:1;margin:0 0 1.05em}
@media (min-width:900px){
  .chapter-body p:first-of-type::first-letter{float:left;font-size:56px;line-height:52px;padding-right:12px;padding-top:6px;font-weight:700;color:var(--accent);font-family:'Playfair Display',serif}
}

/* nav + controls (restored) */
.nav{position:fixed;left:0;right:0;bottom:18px;display:flex;justify-content:space-between;padding:0 24px;pointer-events:none;z-index:1600}
.nav button{pointer-events:auto;padding:12px 18px;border-radius:22px;border:none;background:linear-gradient(145deg,#202021,#121213);color:var(--accent);font-weight:700;cursor:pointer;box-shadow:var(--btn-shadow)}

/* slim right progress bar (modern) */
#progressSlim{position:fixed;right:18px;top:56px;width:8px;height:68vh;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden;z-index:1600;display:flex;align-items:flex-start}
#progressFill{width:100%;height:0;background:linear-gradient(180deg,var(--accent), #d4d4b8);transition:height .12s linear;border-radius:999px}

/* cover overlay (same as original) */
.cover-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:220;pointer-events:none;opacity:0;transform:scale(.98);transition:opacity .45s,transform .45s}
.cover-overlay.show{opacity:1;pointer-events:auto;transform:scale(1)}
.cover-card{width:68vw;max-width:840px;border-radius:16px;overflow:hidden;box-shadow:0 40px 140px rgba(0,0,0,0.85)}
.cover-card img{width:100%;height:auto;display:block}

/* fog + cursor (unchanged) */
#fog{position:fixed;inset:0;background:radial-gradient(circle at 50% 40%, rgba(255,255,255,0.02), rgba(255,255,255,0.01) 10%, rgba(0,0,0,0.85) 40%);pointer-events:none;opacity:0;transition:opacity .35s;z-index:200}
#cursorGlow{position:fixed;width:16px;height:16px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;box-shadow:0 0 36px 8px rgba(245,245,220,0.22);transform:translate(-50%,-50%);z-index:300;transition:all .08s linear}

/* reading mode hides sidebar (original) */
body.reading #sidebar{transform:translateX(-120%);opacity:0;pointer-events:none}
body.reading #main{padding:12px}

/* responsive */
@media (max-width:900px){#sidebar{display:none}#viewerInner{padding:20px}.cover-card{width:86vw}#progressSlim{display:none}}
</style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h1>Comick Library</h1>
    <div class="controls">
      <label class="add-btn">Select EPUB<input id="epubInput" type="file" accept=".epub"></label>
      <label class="add-btn">Upload Cover (opt.)<input id="coverInput" type="file" accept="image/*"></label>
      <div style="display:flex;gap:8px">
        <button id="addSeriesBtn" class="add-btn">Add</button>
        <button id="downloadAllBtn" class="add-btn">Download All</button>
      </div>
    </div>
    <div id="statusMsg">Ready</div>
    <div class="tiles" id="tiles"></div>
  </aside>

  <main id="main">
    <div id="homepageView" style="width:100%;max-width:1400px">
      <div class="headerRow">
        <h2>Your Library</h2>
        <div style="color:var(--muted);font-size:13px">Click to open • Right-click to delete • Resumes automatically</div>
      </div>

      <div id="libraryGrid" class="libraryGrid"></div>
    </div>

    <!-- reader overlay -->
    <div id="readerWrap">
      <div id="readerCard">
        <div id="readerHeader">
          <h2 id="seriesTitle">Series</h2>
          <div style="display:flex;gap:10px;align-items:center">
            <button id="gotoHome" class="add-btn">Library</button>
            <button id="downloadEpub" class="add-btn">Download</button>
          </div>
        </div>

        <div id="viewerContainer">
          <div id="viewer" tabindex="0" aria-live="polite">
            <div id="viewerInner"></div>
          </div>
        </div>

      </div>

      <div class="nav" style="pointer-events:auto">
        <button id="prevBtn" class="btn">⟵ Prev</button>
        <button id="nextBtn" class="btn">Next ⟶</button>
      </div>

      <div id="progressSlim"><div id="progressFill"></div></div>
    </div>

  </main>
</div>

<div id="coverOverlay" class="cover-overlay"><div class="cover-card" id="coverCard"><img id="coverCardImg" src="" alt="cover"></div></div>
<div id="fog"></div>
<div id="cursorGlow"></div>

<!-- cover prompt modal (minimal) -->
<div id="coverModal" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:2000;background:rgba(0,0,0,0.6)">
  <div style="background:#fff;color:#111;padding:18px;border-radius:10px;max-width:760px;width:92%">
    <div style="font-weight:700;margin-bottom:8px">Add book — cover</div>
    <div style="display:flex;gap:12px;align-items:flex-start">
      <div id="coverPreviewBox" style="width:220px;height:320px;border-radius:8px;overflow:hidden;background:#f4f4f4;display:flex;align-items:center;justify-content:center">No cover</div>
      <div style="flex:1">
        <div id="coverText" style="margin-bottom:8px;color:#222">We couldn't find a cover automatically — upload one or proceed with a placeholder.</div>
        <input id="coverFileInput" type="file" accept="image/*">
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
          <button id="coverCancel" style="padding:8px 12px;border-radius:8px">Cancel</button>
          <button id="coverConfirm" style="padding:8px 12px;border-radius:8px;background:#111;color:#fff">Add Book</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* Restored code base with targeted fixes:
   - original look preserved
   - reader overlay isolated and wider (desktop)
   - native scrollbar hidden; slim right progress shows true scroll percent
   - cover extraction + prompt before saving
   - lazy in-place hydration of chapters
   - IndexedDB persists EPUB blob and progress
*/

/* IndexedDB helpers */
const DB_NAME='comick_restored_final_v1', STORE='series';
let db=null;
async function openDB(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=e=>{ db=e.target.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE,{keyPath:'id'}); }; r.onsuccess=e=>{ db=e.target.result; res(db); }; r.onerror=rej; });}
async function getAll(){ if(!db) await openDB(); return new Promise(res=>{ const tx=db.transaction(STORE,'readonly'); tx.objectStore(STORE).getAll().onsuccess = e => res(e.target.result); });}
async function getById(id){ if(!db) await openDB(); return new Promise(res=>{ const tx=db.transaction(STORE,'readonly'); tx.objectStore(STORE).get(id).onsuccess = e => res(e.target.result); });}
async function putObj(o){ if(!db) await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); const r=tx.objectStore(STORE).put(o); r.onsuccess=()=>res(); r.onerror=rej; });}
async function deleteById(id){ if(!db) await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readwrite'); const r=tx.objectStore(STORE).delete(id); r.onsuccess=()=>res(); r.onerror=rej; });}

/* DOM */
const epubInput = document.getElementById('epubInput'), coverInput = document.getElementById('coverInput');
const addSeriesBtn = document.getElementById('addSeriesBtn'), tiles = document.getElementById('tiles'), libraryGrid = document.getElementById('libraryGrid');
const statusMsg = document.getElementById('statusMsg');
const readerWrap = document.getElementById('readerWrap'), readerCard = document.getElementById('readerCard');
const viewer = document.getElementById('viewer'), viewerInner = document.getElementById('viewerInner');
const seriesTitle = document.getElementById('seriesTitle'), prevBtn = document.getElementById('prevBtn'), nextBtn = document.getElementById('nextBtn');
const gotoHome = document.getElementById('gotoHome'), downloadEpubBtn = document.getElementById('downloadEpub');
const progressFill = document.getElementById('progressFill');
const coverOverlay = document.getElementById('coverOverlay'), coverCardImg = document.getElementById('coverCardImg');

const coverModal = document.getElementById('coverModal'), coverPreviewBox = document.getElementById('coverPreviewBox');
const coverText = document.getElementById('coverText'), coverFileInput = document.getElementById('coverFileInput');
const coverCancel = document.getElementById('coverCancel'), coverConfirm = document.getElementById('coverConfirm');

let library=[], currentSeries=null, currentZip=null, chaptersMeta=[], observer=null, currentChapterIndex=0;
let pendingImport = null;

/* util */
function uid(){ return 's_' + Date.now() + '_' + Math.random().toString(36).slice(2,8); }
function showStatus(t){ statusMsg.textContent = t; }
function readAsArrayBuffer(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsArrayBuffer(file); });}
function dataURLFromFile(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(file); });}
function downloadBlob(b,name){ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); },1200); }

/* zip helpers (robust) */
function tryGetFile(zip,path){
  if(!path) return null;
  if(zip.file(path)) return zip.file(path);
  try{ const d=decodeURIComponent(path); if(zip.file(d)) return zip.file(d); }catch(e){}
  const p=path.replace(/^\.\//,'').replace(/^\/+/,'');
  if(zip.file(p)) return zip.file(p);
  const name=p.split('/').pop();
  const keys=Object.keys(zip.files);
  const found=keys.find(k=>k.endsWith('/'+name) || k.endsWith(name));
  return found? zip.file(found): null;
}
function xmlParse(str){ try{ return (new DOMParser()).parseFromString(str,'application/xml'); }catch(e){ return null; } }
async function findOpfPath(zip){
  const c= tryGetFile(zip,'META-INF/container.xml') || tryGetFile(zip,'container.xml');
  if(!c) return null;
  const txt = await c.async('string'); const doc = xmlParse(txt); if(!doc) return null;
  const rf = doc.getElementsByTagName('rootfile')[0]; if(rf && rf.getAttribute) return rf.getAttribute('full-path');
  const all=doc.getElementsByTagName('*'); for(const n of all) if(n.localName === 'rootfile' && n.getAttribute){ const p=n.getAttribute('full-path'); if(p) return p; }
  return null;
}
async function readSpineFromZip(zip){
  const opfPath = await findOpfPath(zip); if(!opfPath) throw new Error('OPF not found');
  const opfFile = tryGetFile(zip, opfPath); if(!opfFile) throw new Error('OPF file missing: ' + opfPath);
  const opfStr = await opfFile.async('string'); const opfDoc = xmlParse(opfStr); if(!opfDoc) throw new Error('OPF parse failed');
  const basePath = opfPath.split('/').slice(0,-1).join('/');
  const manifestMap = {}; const manEls = opfDoc.getElementsByTagName('manifest'); const items = manEls.length ? manEls[0].getElementsByTagName('item') : opfDoc.getElementsByTagName('item');
  for(const it of items){ const id = it.getAttribute('id') || it.getAttribute('xml:id') || ''; manifestMap[id] = { href: it.getAttribute('href'), mediaType: it.getAttribute('media-type'), properties: it.getAttribute('properties') }; }
  const spineEls = opfDoc.getElementsByTagName('spine'); const itemrefs = spineEls.length ? spineEls[0].getElementsByTagName('itemref') : opfDoc.getElementsByTagName('itemref');
  const spineList = [];
  for(const ir of itemrefs){ const idref = ir.getAttribute('idref') || ir.getAttribute('id') || ir.getAttribute('href') || ''; spineList.push(idref); }
  if(spineList.length === 0){ for(const key in manifestMap){ const m = manifestMap[key]; if(m.mediaType && (m.mediaType.includes('html') || m.mediaType.includes('xhtml') || m.mediaType.includes('xml'))) spineList.push(key); } }
  return { basePath, manifestMap, spineList, opfDoc };
}
function buildChaptersFromManifest(basePath, manifestMap, spineList){
  const chapters = [];
  for(const idref of spineList){
    let item = manifestMap[idref];
    if(!item){ for(const k in manifestMap) if(k === idref || manifestMap[k].href === idref) item = manifestMap[k]; }
    if(!item) continue;
    const href = (basePath ? basePath + '/' : '') + item.href;
    chapters.push({ href, idref, title: item.href });
  }
  if(chapters.length === 0){
    for(const k in manifestMap){
      const it = manifestMap[k];
      if(it.mediaType && (it.mediaType.includes('html')||it.mediaType.includes('xhtml')||it.mediaType.includes('xml'))) chapters.push({ href: (basePath? basePath + '/':'') + it.href, idref:k, title: it.href});
    }
  }
  return chapters;
}
async function loadChapterHtml(zip, basePath, href){
  const file = tryGetFile(zip, href) || tryGetFile(zip, decodeURIComponent(href));
  if(!file) throw new Error('Chapter file missing: ' + href);
  const raw = await file.async('string');
  let doc;
  try{ doc = (new DOMParser()).parseFromString(raw,'application/xml'); }catch(e){ doc = (new DOMParser()).parseFromString(raw,'text/html'); }
  if(!doc) throw new Error('Failed parsing chapter: ' + href);

  // inline CSS
  const linkEls = Array.from(doc.getElementsByTagName('link'));
  for(const link of linkEls){
    const rel=(link.getAttribute('rel')||'').toLowerCase();
    if(rel==='stylesheet'){
      const cssHref=link.getAttribute('href')||'';
      const candidates = [(basePath? basePath + '/':'')+cssHref, cssHref, decodeURIComponent(cssHref)];
      let cssFile=null;
      for(const c of candidates){ cssFile = tryGetFile(zip,c); if(cssFile) break; }
      if(cssFile){ try{ const css = await cssFile.async('string'); const style = doc.createElement('style'); style.textContent = css; link.parentNode.replaceChild(style, link); }catch(e){ link.remove(); } } else link.remove();
    }
  }

  // inline images
  const imgs = Array.from(doc.getElementsByTagName('img'));
  for(const img of imgs){
    const src = img.getAttribute('src') || ''; if(!src) continue;
    const candidates=[(basePath? basePath + '/':'')+src, src, decodeURIComponent(src)];
    let imgFile=null;
    for(const c of candidates){ imgFile = tryGetFile(zip,c); if(imgFile) break; }
    if(imgFile){ try{ const blob = await imgFile.async('blob'); const url = URL.createObjectURL(blob); img.setAttribute('src', url); img.setAttribute('loading','lazy'); }catch(e){ console.warn('img inline fail', src, e); } }
  }

  const serializer = new XMLSerializer(); const bodies = doc.getElementsByTagName('body'); let html = '';
  if(bodies && bodies.length>0) html = serializer.serializeToString(bodies[0]).replace(/^<body[^>]*>/i,'').replace(/<\/body>$/i,''); else html = serializer.serializeToString(doc);
  let title = ''; const t = doc.getElementsByTagName('title')[0] || (doc.querySelector && doc.querySelector('h1'));
  if(t) title = (t.textContent||'').trim();
  return { html, title: title || href.split('/').pop() };
}

/* attempt to extract cover from OPF (best-effort) */
async function tryExtractCover(zip, opfDoc, manifestMap, basePath){
  try{
    // <meta name="cover" content="cover-id" />
    const metas = opfDoc.getElementsByTagName('meta');
    for(const m of metas){ if((m.getAttribute('name')||'').toLowerCase() === 'cover'){ const id = m.getAttribute('content'); if(id && manifestMap[id]){ const f = tryGetFile(zip, (basePath? basePath + '/':'') + manifestMap[id].href) || tryGetFile(zip, manifestMap[id].href); if(f){ const blob = await f.async('blob'); return await dataURLFromBlob(blob); } } } }
  }catch(e){}
  try{
    for(const k in manifestMap){
      const it = manifestMap[k];
      if(it.properties && it.properties.includes && it.properties.includes('cover-image')){ const f = tryGetFile(zip, (basePath? basePath + '/':'') + it.href) || tryGetFile(zip, it.href); if(f){ const blob = await f.async('blob'); return await dataURLFromBlob(blob); } }
    }
    for(const k in manifestMap){
      const it = manifestMap[k];
      if((it.href||'').toLowerCase().includes('cover') && it.mediaType && it.mediaType.startsWith('image')){ const f = tryGetFile(zip, (basePath? basePath + '/':'') + it.href) || tryGetFile(zip, it.href); if(f){ const blob = await f.async('blob'); return await dataURLFromBlob(blob); } }
    }
  }catch(e){}
  return null;
}
function dataURLFromBlob(b){ return new Promise(res=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(b); });}

/* render library (restored look) */
async function renderLibrary(){
  tiles.innerHTML=''; libraryGrid.innerHTML=''; showStatus('Loading library...');
  const list = await getAll().catch(()=>[]);
  library = list.sort((a,b)=>(a.title||'').localeCompare(b.title||''));
  if(library.length === 0){ libraryGrid.innerHTML = '<div style="color:var(--muted);padding:28px">Library empty — import an EPUB</div>'; showStatus('Ready'); return; }
  for(const s of library){
    // left tiles (small)
    const tile = document.createElement('div'); tile.className='tile';
    const img = document.createElement('img'); img.src = s.cover || placeholderSVG(s.title); tile.appendChild(img);
    const meta = document.createElement('div'); meta.className='meta'; const t = document.createElement('span'); t.className='title'; t.textContent = s.title || 'Untitled'; const r = document.createElement('span'); r.className='resume'; r.textContent = (s.lastIndex >= 0) ? 'Resume' : ''; meta.appendChild(t); meta.appendChild(r); tile.appendChild(meta);
    tile.addEventListener('contextmenu', ev=>{ ev.preventDefault(); if(confirm(`Delete "${s.title}"?`)){ deleteById(s.id).then(()=> renderLibrary()); } });
    tile.addEventListener('click', ()=> openSeriesWithCover(s.id));
    tiles.appendChild(tile);

    // main grid
    const card = document.createElement('div'); card.style.background='linear-gradient(180deg, rgba(255,255,255,0.008), rgba(255,255,255,0.003))'; card.style.borderRadius='12px'; card.style.padding='8px'; card.style.boxShadow='var(--card-shadow)';
    card.style.display='flex'; card.style.flexDirection='column'; card.style.gap='8px';
    const cover = document.createElement('div'); cover.style.height='260px'; cover.style.borderRadius='8px'; cover.style.overflow='hidden';
    const cimg = document.createElement('img'); cimg.src = s.cover || placeholderSVG(s.title); cimg.style.width='100%'; cimg.style.height='100%'; cimg.style.objectFit='cover'; cover.appendChild(cimg); card.appendChild(cover);
    const title = document.createElement('div'); title.style.fontFamily="'Playfair Display', serif"; title.style.fontSize='16px'; title.style.color='var(--accent)'; title.textContent = s.title; card.appendChild(title);
    const meta2 = document.createElement('div'); meta2.style.display='flex'; meta2.style.justifyContent='space-between'; meta2.style.color='var(--muted)'; meta2.textContent = (s.lastIndex ? 'Resume' : 'New'); card.appendChild(meta2);
    card.addEventListener('click', ()=> openSeriesWithCover(s.id));
    card.addEventListener('contextmenu', ev=>{ ev.preventDefault(); if(confirm(`Delete "${s.title}"?`)){ deleteById(s.id).then(()=> renderLibrary()); } });
    libraryGrid.appendChild(card);
  }
  showStatus('Ready');
}
function placeholderSVG(title){ return 'data:image/svg+xml;utf8,' + encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='800' height='1200'><rect width='100%' height='100%' fill='#0b0b0d'/><text x='50%' y='54%' font-size='28' fill='#efe7c9' text-anchor='middle' font-family='Playfair Display'>${(title||'Untitled')}</text></svg>`); }

/* Add series flow with cover detection & prompt */
epubInput.addEventListener('change', async (e)=>{
  const f = epubInput.files[0]; if(!f) return;
  try{
    showStatus('Reading EPUB for cover...');
    const ab = await readAsArrayBuffer(f);
    const zip = await JSZip.loadAsync(ab);
    const spineData = await (async ()=>{ try{ return await readSpineFromZip(zip); }catch(e){ return null; } })();
    let detectedCover = null;
    if(spineData && spineData.opfDoc !== undefined){
      try{ detectedCover = await tryExtractCover(zip, spineData.opfDoc, spineData.manifestMap, spineData.basePath); }catch(e){ detectedCover = null; }
    }
    // store pending import object (we'll finalize on "Add" click)
    pendingImport = { file: f, arrayBuffer: ab, detectedCover, zip, spineData };
    // if coverInput has a file, use that directly (user provided)
    if(coverInput.files && coverInput.files[0]){
      const durl = await dataURLFromFile(coverInput.files[0]);
      pendingImport.chosenCover = durl;
      await finalizeAdd(); // no modal
      return;
    }
    // if detection succeeded, show modal with preview and allow replacement
    if(detectedCover){
      showCoverModal(detectedCover);
    } else {
      // prompt user to upload or accept placeholder
      showCoverModal(null);
    }
  }catch(err){ console.error(err); alert('Failed to read EPUB: ' + (err.message||err)); epubInput.value=''; showStatus('Ready'); pendingImport=null; }
});

function showCoverModal(detected){
  coverPreviewBox.innerHTML = detected ? `<img src="${detected}" style="width:100%;height:100%;object-fit:cover">` : '<span style="color:#777">No cover</span>';
  coverText.textContent = detected ? 'Auto-detected cover — upload to replace or click Add Book.' : 'No cover found — upload an image or click Add Book to proceed with placeholder.';
  coverFileInput.value = '';
  coverModal.style.display = 'flex';
  // store detected for confirm
  pendingImport.chosenCover = detected || null;
}

coverFileInput.addEventListener('change', async ()=>{
  const f = coverFileInput.files[0]; if(!f) return;
  const durl = await dataURLFromFile(f);
  coverPreviewBox.innerHTML = `<img src="${durl}" style="width:100%;height:100%;object-fit:cover">`;
  pendingImport.chosenCover = durl;
});
coverCancel.addEventListener('click', ()=>{ coverModal.style.display='none'; pendingImport=null; epubInput.value=''; showStatus('Ready'); });
coverConfirm.addEventListener('click', async ()=>{
  coverModal.style.display='none';
  await finalizeAdd();
});

/* finalize add: store in DB */
async function finalizeAdd(){
  if(!pendingImport) return;
  try{
    showStatus('Saving book...');
    const id = uid();
    const title = pendingImport.file.name.replace(/\.epub$/i,'') || id;
    const blob = new Blob([pendingImport.arrayBuffer], { type: 'application/epub+zip' });
    const cover = pendingImport.chosenCover || null;
    await putObj({ id, title, epub: blob, cover, lastIndex: 0 });
    // clear inputs
    epubInput.value=''; coverInput.value='';
    pendingImport = null;
    await renderLibrary();
    showStatus('Ready');
  }catch(e){ console.error(e); alert('Save failed'); showStatus('Ready'); }
}

/* cover overlay -> show then open reader (nice touch) */
async function openSeriesWithCover(id){
  const s = await getById(id);
  if(!s) return alert('Series missing');
  currentSeries = s;
  coverCardImg.src = s.cover || placeholderSVG(s.title);
  document.getElementById('coverOverlay').classList.add('show');
  setTimeout(()=>{ document.getElementById('coverOverlay').classList.remove('show'); openSeries(id); }, 600);
}

/* open series (reader) */
async function openSeries(id){
  showStatus('Preparing book...');
  try{
    const s = await getById(id); if(!s) throw new Error('Series missing');
    currentSeries = s;
    seriesTitle.textContent = s.title || 'Series';
    // hide homepage, show reader overlay
    homepageView.style.display='none';
    readerWrap.style.display='flex';
    document.body.classList.add('reading');
    // show placeholder while preparing
    viewerInner.innerHTML = '<div style="padding:22px;color:var(--muted)">Preparing book…</div>';
    currentZip = await JSZip.loadAsync(await s.epub.arrayBuffer());
    const spineData = await readSpineFromZip(currentZip);
    const base = spineData.basePath, manifest = spineData.manifestMap, spineList = spineData.spineList;
    chaptersMeta = buildChaptersFromManifest(base, manifest, spineList);
    if(chaptersMeta.length === 0){
      viewerInner.innerHTML = '<div style="padding:22px;color:var(--muted)">No readable chapters found.</div>';
      showStatus('Ready');
      return;
    }
    // create placeholders inside viewerInner (keep same node, avoid replacement)
    viewerInner.innerHTML = '';
    for(let i=0;i<chaptersMeta.length;i++){
      const ph = document.createElement('div');
      ph.className = 'chapter-placeholder';
      ph.dataset.idx = i;
      ph.style.minHeight = Math.round(Math.max(160, window.innerHeight * 0.22)) + 'px';
      ph.style.padding = '18px 0';
      ph.style.color = 'var(--muted)';
      ph.textContent = chaptersMeta[i].title || ('Chapter '+(i+1));
      viewerInner.appendChild(ph);
    }
    // set up observer with conservative rootMargin to avoid loading far ahead
    if(observer) observer.disconnect();
    observer = new IntersectionObserver(async (entries)=>{
      for(const e of entries){
        if(e.isIntersecting){
          const idx = Number(e.target.dataset.idx);
          if(!e.target.classList.contains('chapter-loaded')) await loadChapterAt(idx);
        }
      }
    }, { root: viewer, rootMargin: '600px', threshold: 0.02 });
    Array.from(viewerInner.querySelectorAll('.chapter-placeholder')).forEach(el=>observer.observe(el));
    // pre-load currentChapterIndex from saved progress
    currentChapterIndex = (s.lastIndex>=0 && s.lastIndex < chaptersMeta.length) ? s.lastIndex : 0;
    // hydrate starting chapter (and next)
    await loadChapterAt(currentChapterIndex);
    if(currentChapterIndex + 1 < chaptersMeta.length) loadChapterAt(currentChapterIndex+1);
    // scroll to saved progress
    setTimeout(()=> scrollToChapter(currentChapterIndex, false), 260);
    // attach scroll handler for progress
    viewer.addEventListener('scroll', throttle(updateProgressBar, 100));
    showStatus('Ready');
  }catch(err){ console.error('openSeries error', err); alert('Failed to open EPUB: ' + (err.message || err)); showStatus('Ready'); }
}

/* load chapter in-place (no node replace) */
async function loadChapterAt(idx){
  if(!currentZip || !chaptersMeta[idx]) return;
  const placeholder = viewerInner.querySelector('.chapter-placeholder[data-idx="'+idx+'"]');
  if(!placeholder) return;
  if(placeholder.classList.contains('chapter-loaded')) return;
  placeholder.classList.add('chapter-loaded');
  try{
    const base = chaptersMeta[idx].href.split('/').slice(0,-1).join('/');
    const res = await loadChapterHtml(currentZip, base, chaptersMeta[idx].href);
    // inject (replace placeholder content but keep node)
    placeholder.classList.remove('chapter-placeholder');
    placeholder.classList.add('chapter');
    placeholder.dataset.idx = idx;
    placeholder.innerHTML = `<div class="chapter-title">${escapeHtml(res.title)}</div><div class="chapter-body">${res.html}</div>`;
    const body = placeholder.querySelector('.chapter-body');
    const hasParagraphs = body.querySelectorAll('p,div,section,article').length > 0;
    if(!hasParagraphs){
      const txt = (body.textContent||'').trim();
      body.innerHTML='';
      const p=document.createElement('p'); p.textContent = txt || '(no extractable text)'; body.appendChild(p);
    } else {
      const pCount = body.querySelectorAll('p').length;
      if(pCount === 0){
        const blocks = Array.from(body.children);
        body.innerHTML='';
        blocks.forEach(b=>{ const p=document.createElement('p'); p.innerHTML = b.innerHTML || b.textContent || ''; body.appendChild(p); });
      }
    }
    // make images lazy + centered
    const imgs = placeholder.querySelectorAll('img');
    imgs.forEach(img=>{ if(!img.loading) img.loading='lazy'; img.style.maxWidth='100%'; img.style.height='auto'; img.style.display='block'; img.style.margin='12px auto'; });
    // reveal
    setTimeout(()=> placeholder.classList.add('visible'), 60);
    const ps = placeholder.querySelectorAll('.chapter-body p');
    ps.forEach((p,i)=> setTimeout(()=> p.classList.add('visible'), 40 + i*20));
    // done
  }catch(e){
    console.error('Chapter load failed', e);
    placeholder.textContent='Failed to load chapter';
  }
}

/* scroll and progress update (true scroll percent of viewer) */
function scrollToChapter(idx, smooth=true){
  const el = viewerInner.querySelector('.chapter[data-idx="'+idx+'"], .chapter-placeholder[data-idx="'+idx+'"]');
  if(el) el.scrollIntoView({behavior: smooth ? 'smooth' : 'auto', block:'start'});
  currentChapterIndex = idx;
  if(currentSeries){ currentSeries.lastIndex = currentChapterIndex; putObj(currentSeries); }
  updateProgressBar();
}
function updateProgressBar(){
  const scrollTop = viewer.scrollTop;
  const scrollHeight = viewer.scrollHeight - viewer.clientHeight;
  const pct = scrollHeight > 0 ? Math.round((scrollTop/scrollHeight)*100) : 0;
  progressFill.style.height = Math.max(3, Math.round((pct/100) * (viewer.clientHeight * 0.68))) + '%'; // visual scale
}

/* nav and keyboard */
prevBtn.addEventListener('click', ()=>{ if(currentChapterIndex>0) scrollToChapter(currentChapterIndex-1); });
nextBtn.addEventListener('click', ()=>{ if(currentChapterIndex < chaptersMeta.length -1) scrollToChapter(currentChapterIndex+1); });
document.addEventListener('keydown', (e)=>{
  const tag = document.activeElement && document.activeElement.tagName.toLowerCase(); if(tag==='input' || tag==='textarea') return;
  if(readerWrap.style.display!=='flex') return;
  if(e.code==='ArrowRight'){ e.preventDefault(); if(currentChapterIndex < chaptersMeta.length -1) scrollToChapter(currentChapterIndex+1); }
  else if(e.code==='ArrowLeft'){ e.preventDefault(); if(currentChapterIndex>0) scrollToChapter(currentChapterIndex-1); }
  else if(e.code==='Space' || e.code==='ArrowDown'){ e.preventDefault(); viewer.scrollBy({ top:360, behavior:'smooth' }); }
  else if(e.code==='ArrowUp'){ e.preventDefault(); viewer.scrollBy({ top:-360, behavior:'smooth' }); }
});

/* download current epub */
downloadEpubBtn.addEventListener('click', async ()=>{ if(!currentSeries) return alert('Open a book first'); const s=await getById(currentSeries.id); if(!s||!s.epub) return alert('EPUB missing'); const blob = s.epub instanceof Blob ? s.epub : new Blob([s.epub], {type:'application/epub+zip'}); downloadBlob(blob, (s.title||'book')+'.epub'); });

/* download all */
document.getElementById('downloadAllBtn').addEventListener('click', async ()=>{ const all = await getAll(); if(!all||all.length===0) return alert('No series'); const z = new JSZip(); for(const s of all) if(s.epub) z.file((s.title||s.id)+'.epub', s.epub); const blob = await z.generateAsync({type:'blob'}); downloadBlob(blob, 'comick_library.zip'); });

/* goto library */
gotoHome.addEventListener('click', ()=>{ readerWrap.style.display='none'; homepageView.style.display='block'; viewerInner.innerHTML=''; if(observer) observer.disconnect(); currentZip=null; currentSeries=null; document.body.classList.remove('reading'); renderLibrary(); });

/* escape HTML */
function escapeHtml(s){ return (''+s).replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }

/* throttle util */
function throttle(fn,wait=120){ let t=null; return (...a)=>{ if(t) return; t=setTimeout(()=>{ t=null; fn(...a); }, wait); }; }

/* cursor glow */
document.addEventListener('mousemove', e=>{ const c = document.getElementById('cursorGlow'); if(c){ c.style.left = e.clientX + 'px'; c.style.top = e.clientY + 'px'; } });

/* init */
(async function init(){
  try{ await openDB(); await renderLibrary(); showStatus('Ready'); }catch(e){ console.error('Init',e); showStatus('Error'); }
})();

</script>
</body>
</html>
